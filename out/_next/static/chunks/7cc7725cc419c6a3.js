(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,603061,e=>{"use strict";var t=e.i(792411),n=e.i(553956),r=e.i(612753),a=e.i(313207),o=e.i(997134),s=e.i(233314),i=e.i(330699),l=e.i(932362),c=e.i(535225),d=e.i(182458),C=e.i(416661),p=e.i(561998),h=e.i(310428),u=e.i(885390),m=e.i(944617),g=e.i(345740),w=e.i(121635);let N={convertEVMChainIdToCoinType(e){if(e>=0x80000000)throw Error("Invalid chainId");return(0x80000000|e)>>>0}};var A=e.i(609191),E=e.i(132882),v=e.i(643009);let f=(0,g.proxy)({suggestions:[],loading:!1}),y=(0,E.withErrorBoundary)({state:f,subscribe:e=>(0,g.subscribe)(f,()=>e(f)),subscribeKey:(e,t)=>(0,w.subscribeKey)(f,e,t),async resolveName(e){try{return await h.BlockchainApiController.lookupEnsName(e)}catch(e){throw Error(e?.reasons?.[0]?.description||"Error resolving name")}},async isNameRegistered(e){try{return await h.BlockchainApiController.lookupEnsName(e),!0}catch{return!1}},async getSuggestions(e){try{return f.loading=!0,f.suggestions=[],f.suggestions=(await h.BlockchainApiController.getEnsNameSuggestions(e)).suggestions||[],f.suggestions}catch(e){throw Error(y.parseEnsApiError(e,"Error fetching name suggestions"))}finally{f.loading=!1}},async getNamesForAddress(e){try{if(!t.ChainController.state.activeCaipNetwork)return[];let n=A.StorageUtil.getEnsFromCacheForAddress(e);if(n)return n;let r=await h.BlockchainApiController.reverseLookupEnsName({address:e});return A.StorageUtil.updateEnsCache({address:e,ens:r,timestamp:Date.now()}),r}catch(e){throw Error(y.parseEnsApiError(e,"Error fetching names for address"))}},async registerName(e){let a=t.ChainController.state.activeCaipNetwork,o=t.ChainController.getAccountData(a?.chainNamespace)?.address,s=r.ConnectorController.getAuthConnector();if(!a)throw Error("Network not found");if(!o||!s)throw Error("Address or auth connector not found");f.loading=!0;try{let r=JSON.stringify({name:e,attributes:{},timestamp:Math.floor(Date.now()/1e3)});v.RouterController.pushTransactionStack({onCancel(){v.RouterController.replace("RegisterAccountName")}});let s=await n.ConnectionController.signMessage(r);f.loading=!1;let i=a.id;if(!i)throw Error("Network not found");let l=N.convertEVMChainIdToCoinType(Number(i));await h.BlockchainApiController.registerEnsName({coinType:l,address:o,signature:s,message:r}),t.ChainController.setAccountProp("profileName",e,a.chainNamespace),A.StorageUtil.updateEnsCache({address:o,ens:[{name:e,registered_at:new Date().toISOString(),updated_at:void 0,addresses:{},attributes:[]}],timestamp:Date.now()}),v.RouterController.replace("RegisterAccountNameSuccess")}catch(n){let t=y.parseEnsApiError(n,`Error registering name ${e}`);throw v.RouterController.replace("RegisterAccountName"),Error(t)}finally{f.loading=!1}},validateName:e=>/^[a-zA-Z0-9-]{4,}$/u.test(e),parseEnsApiError:(e,t)=>e?.reasons?.[0]?.description||t});var I=e.i(467473),T=e.i(308769);let b={id:"2b92315d-eab7-5bef-84fa-089a131333f5",name:"USD Coin",symbol:"USDC",networks:[{name:"ethereum-mainnet",display_name:"Ethereum",chain_id:"1",contract_address:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"},{name:"polygon-mainnet",display_name:"Polygon",chain_id:"137",contract_address:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"}]},U={id:"USD",payment_method_limits:[{id:"card",min:"10.00",max:"7500.00"},{id:"ach_bank_account",min:"10.00",max:"25000.00"}]},k={providers:m.ONRAMP_PROVIDERS,selectedProvider:null,error:null,purchaseCurrency:b,paymentCurrency:U,purchaseCurrencies:[b],paymentCurrencies:[],quotesLoading:!1},O=(0,g.proxy)(k),S=(0,E.withErrorBoundary)({state:O,subscribe:e=>(0,g.subscribe)(O,()=>e(O)),subscribeKey:(e,t)=>(0,w.subscribeKey)(O,e,t),setSelectedProvider(e){if(e&&"meld"===e.name){let n=t.ChainController.state.activeChain,r=n===i.ConstantsUtil.CHAIN.SOLANA?"SOL":"USDC",a=n?t.ChainController.state.chains.get(n)?.accountState?.address??"":"",s=new URL(e.url);s.searchParams.append("publicKey",m.MELD_PUBLIC_KEY),s.searchParams.append("destinationCurrencyCode",r),s.searchParams.append("walletAddress",a),s.searchParams.append("externalCustomerId",o.OptionsController.state.projectId),O.selectedProvider={...e,url:s.toString()}}else O.selectedProvider=e},setOnrampProviders(e){Array.isArray(e)&&e.every(e=>"string"==typeof e)?O.providers=m.ONRAMP_PROVIDERS.filter(t=>e.includes(t.name)):O.providers=[]},setPurchaseCurrency(e){O.purchaseCurrency=e},setPaymentCurrency(e){O.paymentCurrency=e},setPurchaseAmount(e){S.state.purchaseAmount=e},setPaymentAmount(e){S.state.paymentAmount=e},async getAvailableCurrencies(){let e=await h.BlockchainApiController.getOnrampOptions();O.purchaseCurrencies=e.purchaseCurrencies,O.paymentCurrencies=e.paymentCurrencies,O.paymentCurrency=e.paymentCurrencies[0]||U,O.purchaseCurrency=e.purchaseCurrencies[0]||b,await C.ApiController.fetchCurrencyImages(e.paymentCurrencies.map(e=>e.id)),await C.ApiController.fetchTokenImages(e.purchaseCurrencies.map(e=>e.symbol))},async getQuote(){O.quotesLoading=!0;try{let e=await h.BlockchainApiController.getOnrampQuote({purchaseCurrency:O.purchaseCurrency,paymentCurrency:O.paymentCurrency,amount:O.paymentAmount?.toString()||"0",network:O.purchaseCurrency?.symbol});return O.quotesLoading=!1,O.purchaseAmount=Number(e?.purchaseAmount.amount),e}catch(e){return O.error=e.message,O.quotesLoading=!1,null}finally{O.quotesLoading=!1}},resetState(){O.selectedProvider=null,O.error=null,O.purchaseCurrency=b,O.paymentCurrency=U,O.purchaseCurrencies=[b],O.paymentCurrencies=[],O.paymentAmount=void 0,O.purchaseAmount=void 0,O.quotesLoading=!1}}),_={eip155:void 0,solana:void 0,polkadot:void 0,bip122:void 0,cosmos:void 0,sui:void 0,stacks:void 0},P=(0,g.proxy)({providers:{..._},providerIds:{..._}}),R={state:P,subscribeKey:(e,t)=>(0,w.subscribeKey)(P,e,t),subscribe:e=>(0,g.subscribe)(P,()=>{e(P)}),subscribeProviders:e=>(0,g.subscribe)(P.providers,()=>e(P.providers)),setProvider(e,t){e&&t&&(P.providers[e]=(0,g.ref)(t))},getProvider(e){if(e)return P.providers[e]},setProviderId(e,t){t&&(P.providerIds[e]=t)},getProviderId(e){if(e)return P.providerIds[e]},reset(){P.providers={..._},P.providerIds={..._}},resetChain(e){P.providers[e]=void 0,P.providerIds[e]=void 0}};var D=e.i(330041),L=e.i(470749),M=e.i(213522),W=e.i(988860),F=e.i(765595),B=e.i(195741),x=e.i(278070);e.i(871184);var H=e.i(323828);e.i(541714);var j=e.i(617111),K=e.i(597424),V=e.i(195253);new AbortController;let q={UNAUTHORIZED_DOMAIN_NOT_ALLOWED:{message:"Unauthorized: origin not allowed",alertErrorKey:"ORIGIN_NOT_ALLOWED"},JWT_VALIDATION_ERROR:{message:"JWT validation error: JWT Token is not yet valid",alertErrorKey:"JWT_TOKEN_NOT_VALID"},INVALID_KEY:{message:"Unauthorized: invalid key",alertErrorKey:"INVALID_PROJECT_ID"}},$={SWITCH_NETWORK_NOT_FOUND:{code:"APKT001",displayMessage:"Network Not Found",debugMessage:"The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration."},ORIGIN_NOT_ALLOWED:{code:"APKT002",displayMessage:"Invalid App Configuration",debugMessage:()=>`The origin ${(0,V.isSafe)()?window.origin:"unknown"} is not in your allow list. Please update your allowed domains at https://dashboard.reown.com.`},IFRAME_LOAD_FAILED:{code:"APKT003",displayMessage:"Network Error: Wallet Load Failed",debugMessage:()=>"Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists."},IFRAME_REQUEST_TIMEOUT:{code:"APKT004",displayMessage:"Wallet Request Timeout",debugMessage:()=>"The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists."},UNVERIFIED_DOMAIN:{code:"APKT005",displayMessage:"Unverified Domain",debugMessage:()=>"Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com."},JWT_TOKEN_NOT_VALID:{code:"APKT006",displayMessage:"Session Expired",debugMessage:"Your session is invalid or expired. Please check your systemâ€™s date and time settings, then reconnect."},INVALID_PROJECT_ID:{code:"APKT007",displayMessage:"Invalid Project ID",debugMessage:"The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID."},PROJECT_ID_NOT_CONFIGURED:{code:"APKT008",displayMessage:"Project ID Missing",debugMessage:"No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com."},SERVER_ERROR_APP_CONFIGURATION:{code:"APKT009",displayMessage:"Server Error",debugMessage:e=>`Unable to fetch App Configuration. ${e}. Please check your network connection and try again shortly. Contact support if the issue persists.`},RATE_LIMITED_APP_CONFIGURATION:{code:"APKT010",displayMessage:"Rate Limited",debugMessage:"You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists."}},z={debugMessage:e=>`[Reown Config Notice] ${e}`},Y={code:"APKTW001",displayMessage:"Inactive Namespace Not Connected",debugMessage:(e,t)=>`An error occurred while connecting an inactive namespace ${e}: "${t}"`};var G=e.i(973399),J=e.i(670126);let X={createLogger(e,t="error"){let n=(0,J.getDefaultLoggerOptions)({level:t}),{logger:r}=(0,J.generatePlatformLogger)({opts:n});return r.error=(...t)=>{for(let n of t)if(n instanceof Error)return void e(n,...t);e(void 0,...t)},r}};var Z=e.i(501055);let Q={extractVersion(e){if(!e||"string"!=typeof e)return null;let t=e.match(/(?:[~^>=<]+\s*)?(?<version>\d+(?:\.\d+){0,2})(?:-[a-zA-Z]+\.\d+)?/u);return t?.groups?.version||null},checkSDKVersion(e){let t=this.extractVersion(e),n=i.ConstantsUtil.IS_DEVELOPMENT;if(!t||!n)return;let r=A.StorageUtil.getLatestAppKitVersion();if(this.isValidVersion(r)&&this.isOlder(t,r))return void console.warn(Z.ConstantsUtil.getSDKVersionWarningMessage(t,r));try{fetch("https://registry.npmjs.org/@reown/appkit/latest").then(e=>e.json()).then(e=>{let n=e.version;this.isOlder(t,n)&&(A.StorageUtil.updateLatestAppKitVersion({timestamp:Date.now(),version:n}),console.warn(Z.ConstantsUtil.getSDKVersionWarningMessage(t,n)))})}catch(e){}},isValidVersion:e=>"string"==typeof e&&/^\d+\.\d+\.\d+$/u.test(e),isOlder(e,t){let n=this.extractVersion(e),r=this.extractVersion(t);if(!n||!r)return!1;function a(e){let t=e.split(".").map(Number);for(;t.length<3;)t.push(0);return t}let o=a(n),s=a(r);for(let e=0;e<Math.max(o.length,s.length);e+=1){let t=o[e]||0,n=s[e]||0;if(t<n)return!0;if(t>n)break}return!1}},ee={TOKEN_ADDRESSES_BY_SYMBOL:{USDC:{8453:"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",84532:"0x036CbD53842c5426634e7929541eC2318f3dCF7e"}},getTokenSymbolByAddress(e){if(!e)return;let[t]=Object.entries(ee.TOKEN_ADDRESSES_BY_SYMBOL).find(([t,n])=>Object.values(n).includes(e))??[];return t}};var et=e.i(203757),en=e.i(371971),er=e.i(720004),ea=e.i(727388);let eo={hexStringToNumber:e=>parseInt(e.startsWith("0x")?e.slice(2):e,16),numberToHexString:e=>`0x${e.toString(16)}`,async getUserInfo(e){let[t,n]=await Promise.all([eo.getAddresses(e),eo.getChainId(e)]);return{chainId:n,addresses:t}},getChainId:async e=>Number(await e.request({method:"eth_chainId"})),async getAddress(e){let[t]=await e.request({method:"eth_accounts"});return t},getAddresses:async e=>await e.request({method:"eth_accounts"}),async addEthereumChain(e,t){let n=t.rpcUrls.chainDefault?.http||[];await e.request({method:"wallet_addEthereumChain",params:[{chainId:eo.numberToHexString(t.id),rpcUrls:[...n],chainName:t.name,nativeCurrency:{name:t.nativeCurrency.name,decimals:t.nativeCurrency.decimals,symbol:t.nativeCurrency.symbol},blockExplorerUrls:[t.blockExplorers?.default.url],iconUrls:[ea.PresetsUtil.NetworkImageIds[t.id]]}]})}},es=0,ei=1;function el(e){return{formatters:void 0,fees:void 0,serializers:void 0,...e}}let ec=el({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"}),ed=el({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"});el({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"}),el({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}}),el({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0}),el({id:"00000008819873e925422c1ff0f99f7c",caipNetworkId:"bip122:00000008819873e925422c1ff0f99f7c",chainNamespace:"bip122",name:"Bitcoin Signet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0});let eC={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},ep={RPC_ERROR_CODE:{USER_REJECTED:5e3,USER_REJECTED_METHODS:5002},getMethodsByChainNamespace:e=>eC[e]||[],createDefaultNamespace(e){return{methods:this.getMethodsByChainNamespace(e),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(e,t){if(!t)return{...e};let n={...e},r=new Set;if(t.methods&&Object.keys(t.methods).forEach(e=>r.add(e)),t.chains&&Object.keys(t.chains).forEach(e=>r.add(e)),t.events&&Object.keys(t.events).forEach(e=>r.add(e)),t.rpcMap&&Object.keys(t.rpcMap).forEach(e=>{let[t]=e.split(":");t&&r.add(t)}),r.forEach(e=>{n[e]||(n[e]=this.createDefaultNamespace(e))}),t.methods&&Object.entries(t.methods).forEach(([e,t])=>{n[e]&&(n[e].methods=t)}),t.chains&&Object.entries(t.chains).forEach(([e,t])=>{n[e]&&(n[e].chains=t)}),t.events&&Object.entries(t.events).forEach(([e,t])=>{n[e]&&(n[e].events=t)}),t.rpcMap){let e=new Set;Object.entries(t.rpcMap).forEach(([t,r])=>{let[a,o]=t.split(":");a&&o&&n[a]&&(n[a].rpcMap||(n[a].rpcMap={}),e.has(a)||(n[a].rpcMap={},e.add(a)),n[a].rpcMap[o]=r)})}return n},createNamespaces(e,t){let n=e.reduce((e,t)=>{let{id:n,chainNamespace:r,rpcUrls:a}=t,o=a.default.http[0];e[r]||(e[r]=this.createDefaultNamespace(r));let s=`${r}:${n}`,i=e[r];switch(i.chains.push(s),s){case ec.caipNetworkId:i.chains.push(ec.deprecatedCaipNetworkId);break;case ed.caipNetworkId:i.chains.push(ed.deprecatedCaipNetworkId)}return i?.rpcMap&&o&&(i.rpcMap[n]=o),e},{});return this.applyNamespaceOverrides(n,t)},resolveReownName:async e=>{let t=await y.resolveName(e),n=Object.values(t?.addresses)||[];return n[0]?.address||!1},getChainsFromNamespaces:(e={})=>Object.values(e).flatMap(e=>Array.from(new Set([...e.chains||[],...e.accounts.map(e=>{let[t,n]=e.split(":");return`${t}:${n}`})]))),isSessionEventData:e=>"object"==typeof e&&null!==e&&"id"in e&&"topic"in e&&"params"in e&&"object"==typeof e.params&&null!==e.params&&"chainId"in e.params&&"event"in e.params&&"object"==typeof e.params.event&&null!==e.params.event,isUserRejectedRequestError(e){try{if("object"==typeof e&&null!==e){let t="number"==typeof e.code,n=t&&e.code===ep.RPC_ERROR_CODE.USER_REJECTED_METHODS,r=t&&e.code===ep.RPC_ERROR_CODE.USER_REJECTED;return n||r}return!1}catch{return!1}},isOriginAllowed(e,t,n){for(let r of[...t,...n])if(r.includes("*")){let t=r.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&");if(RegExp(`^${t.replace(/\\\*/gu,".*")}$`,"u").test(e))return!0}else try{if(new URL(r).origin===e)return!0}catch(t){if(r===e)return!0}return!1},listenWcProvider({universalProvider:e,namespace:t,onConnect:n,onDisconnect:r,onAccountsChanged:a,onChainChanged:o,onDisplayUri:s}){n&&e.on("connect",()=>{n(ep.getWalletConnectAccounts(e,t))}),r&&e.on("disconnect",()=>{r()}),a&&e.on("accountsChanged",n=>{try{let r=e.session?.namespaces?.[t]?.accounts||[],o=e.rpcProviders?.[t]?.getDefaultChain(),s=n.map(e=>{let n=r.find(n=>n.includes(`${t}:${o}:${e}`));if(!n)return;let{chainId:a,chainNamespace:s}=c.ParseUtil.parseCaipAddress(n);return{address:e,chainId:a,chainNamespace:s}}).filter(e=>void 0!==e);s.length>0&&a(s)}catch(e){console.warn("Failed to parse accounts for namespace on accountsChanged event",t,n,e)}}),o&&e.on("chainChanged",e=>{o(e)}),s&&e.on("display_uri",e=>{s(e)})},getWalletConnectAccounts(e,t){let n=new Set,r=e?.session?.namespaces?.[t]?.accounts?.map(e=>c.ParseUtil.parseCaipAddress(e)).filter(({address:e})=>!n.has(e.toLowerCase())&&(n.add(e.toLowerCase()),!0));return r&&r.length>0?r:[]}};class eh{constructor(e){this.namespace=e.namespace}async syncConnections(e){switch(this.namespace){case i.ConstantsUtil.CHAIN.EVM:await this.syncEVMConnections(e);break;case i.ConstantsUtil.CHAIN.SOLANA:await this.syncSolanaConnections(e);break;case i.ConstantsUtil.CHAIN.BITCOIN:await this.syncBitcoinConnections(e);break;default:throw Error(`Unsupported chain namespace: ${this.namespace}`)}}async syncEVMConnections({connectors:e,caipNetworks:t,universalProvider:n,onConnection:r,onListenProvider:a}){await Promise.all(e.filter(e=>{let{hasDisconnected:t,hasConnected:n}=G.HelpersUtil.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(async e=>{if(e.id===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let a=ep.getWalletConnectAccounts(n,this.namespace),o=t.find(e=>e.chainNamespace===this.namespace&&e.id.toString()===a[0]?.chainId?.toString());a.length>0&&r({connectorId:e.id,accounts:a.map(e=>({address:e.address})),caipNetwork:o})}else{let{accounts:n,chainId:o}=await x.ConnectorUtil.fetchProviderData(e);if(n.length>0&&o){let s=t.find(e=>e.chainNamespace===this.namespace&&e.id.toString()===o.toString());r({connectorId:e.id,accounts:n.map(e=>({address:e})),caipNetwork:s}),e.provider&&e.id!==i.ConstantsUtil.CONNECTOR_ID.AUTH&&e.id!==i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT&&a(e.id,e.provider)}}}))}async syncSolanaConnections({connectors:e,caipNetwork:t,universalProvider:n,onConnection:r,onListenProvider:a}){await Promise.all(e.filter(e=>{let{hasDisconnected:t,hasConnected:n}=G.HelpersUtil.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(async e=>{if(e.id===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let a=ep.getWalletConnectAccounts(n,this.namespace);a.length>0&&r({connectorId:e.id,accounts:a.map(e=>({address:e.address})),caipNetwork:t})}else{let n=await e.connect({chainId:t?.id});n&&(r({connectorId:e.id,accounts:[{address:n}],caipNetwork:t}),a(e.id,e.provider))}}))}async syncBitcoinConnections({connectors:e,caipNetwork:t,universalProvider:n,onConnection:r,onListenProvider:o}){await Promise.all(e.filter(e=>{let{hasDisconnected:t,hasConnected:n}=G.HelpersUtil.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(async e=>{if(e.id===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT){let a=ep.getWalletConnectAccounts(n,this.namespace);a.length>0&&r({connectorId:e.id,accounts:a.map(e=>({address:e.address})),caipNetwork:t});return}let s=await e.connect(),l=await e.getAccountAddresses(),c=l?.map(e=>a.CoreHelperUtil.createAccount(i.ConstantsUtil.CHAIN.BITCOIN,e.address,e.purpose||"payment",e.publicKey,e.path));if(c&&c.length>1&&(c=[{namespace:i.ConstantsUtil.CHAIN.BITCOIN,publicKey:c[es]?.publicKey??"",path:c[es]?.path??"",address:c[es]?.address??"",type:"payment"},{namespace:i.ConstantsUtil.CHAIN.BITCOIN,publicKey:c[ei]?.publicKey??"",path:c[ei]?.path??"",address:c[ei]?.address??"",type:"ordinal"}]),!(e.chains.find(e=>e.id===t?.id)||e.chains[0]))throw Error("The connector does not support any of the requested chains");s&&(o(e.id,e.provider),r({connectorId:e.id,accounts:c.map(e=>({address:e.address,type:e.type,publicKey:e.publicKey,path:e.path})),caipNetwork:t}))}))}getConnection({address:e,connectorId:t,connections:n,connectors:r}){if(t){let a=n.find(e=>G.HelpersUtil.isLowerCaseMatch(e.connectorId,t));if(!a)return null;let o=r.find(e=>G.HelpersUtil.isLowerCaseMatch(e.id,a.connectorId)),s=e?a.accounts.find(t=>G.HelpersUtil.isLowerCaseMatch(t.address,e)):a.accounts[0];return{...a,account:s,connector:o}}let a=n.find(e=>e.accounts.length>0&&r.some(t=>G.HelpersUtil.isLowerCaseMatch(t.id,e.connectorId)));if(a){let[e]=a.accounts,t=r.find(e=>G.HelpersUtil.isLowerCaseMatch(e.id,a.connectorId));return{...a,account:e,connector:t}}return null}}let eu=["http://localhost:*","https://localhost:*","http://127.0.0.1:*","https://127.0.0.1:*","https://*.pages.dev","https://*.vercel.app","https://*.ngrok-free.app","https://secure-mobile.walletconnect.com","https://secure-mobile.walletconnect.org"];class em{constructor({provider:e,namespace:n}){this.id=i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,this.name=ea.PresetsUtil.ConnectorNamesMap[i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT],this.type="WALLET_CONNECT",this.imageId=ea.PresetsUtil.ConnectorImageIds[i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT],this.getCaipNetworks=t.ChainController.getCaipNetworks.bind(t.ChainController),this.caipNetworks=this.getCaipNetworks(),this.provider=e,this.chain=n}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){let e=this.getCaipNetworks(),t=o.OptionsController.state.universalProviderConfigOverride,n=ep.createNamespaces(e,t);await this.provider.connect({optionalNamespaces:n})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){let e=this.chains.map(e=>e.caipNetworkId);return L.SIWXUtil.universalProviderAuthenticate({universalProvider:this.provider,chains:e,methods:eg})}}let eg=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],ew=[i.ConstantsUtil.CONNECTOR_ID.AUTH,i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];class eN{constructor(e){this.availableConnectors=[],this.availableConnections=[],this.providerHandlers={},this.eventListeners=new Map,this.getCaipNetworks=e=>t.ChainController.getCaipNetworks(e),this.getConnectorId=e=>r.ConnectorController.getConnectorId(e),e&&this.construct(e),e?.namespace&&(this.connectionManager=new eh({namespace:e.namespace}))}construct(e){this.projectId=e.projectId,this.namespace=e.namespace,this.adapterType=e.adapterType}get connectors(){return this.availableConnectors}get connections(){return this.availableConnections}get networks(){return this.getCaipNetworks(this.namespace)}onAuthConnected({accounts:e,chainId:t}){let n=this.getCaipNetworks().filter(e=>e.chainNamespace===this.namespace).find(e=>e.id.toString()===t?.toString());e&&n&&this.addConnection({connectorId:i.ConstantsUtil.CONNECTOR_ID.AUTH,accounts:e,caipNetwork:n})}setAuthProvider(e){e.onConnect(this.onAuthConnected.bind(this)),e.onSocialConnected(this.onAuthConnected.bind(this)),this.addConnector({id:i.ConstantsUtil.CONNECTOR_ID.AUTH,type:"AUTH",name:i.ConstantsUtil.CONNECTOR_NAMES.AUTH,provider:e,imageId:ea.PresetsUtil.ConnectorImageIds[i.ConstantsUtil.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}addConnector(...e){let t=new Set;this.availableConnectors=[...e,...this.availableConnectors].filter(e=>!t.has(e.id)&&(t.add(e.id),!0)),this.emit("connectors",this.availableConnectors)}addConnection(...e){let t=new Set;this.availableConnections=[...e,...this.availableConnections].filter(e=>!t.has(e.connectorId.toLowerCase())&&(t.add(e.connectorId.toLowerCase()),!0)),this.emit("connections",this.availableConnections)}deleteConnection(e){this.availableConnections=this.availableConnections.filter(t=>!G.HelpersUtil.isLowerCaseMatch(t.connectorId,e)),this.emit("connections",this.availableConnections)}clearConnections(e=!1){this.availableConnections=[],e&&this.emit("connections",this.availableConnections)}setStatus(e,n){t.ChainController.setAccountProp("status",e,n)}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e)?.add(t)}off(e,t){let n=this.eventListeners.get(e);n&&n.delete(t)}removeAllEventListeners(){this.eventListeners.forEach(e=>{e.clear()})}emit(e,t){let n=this.eventListeners.get(e);n&&n.forEach(e=>e(t))}async connectWalletConnect(e){try{let e=this.getWalletConnectConnector();return{clientId:(await e.connectWalletConnect()).clientId}}catch(e){if(ep.isUserRejectedRequestError(e))throw new er.UserRejectedRequestError(e);throw e}}async switchNetwork(e){let{caipNetwork:t,providerType:n}=e;if(!e.provider)return;let r="provider"in e.provider?e.provider.provider:e.provider;if("WALLET_CONNECT"===n)return void r.setDefaultChain(t.caipNetworkId);if(r&&"AUTH"===n){let e=(0,B.getPreferredAccountType)(t.chainNamespace);await r.switchNetwork({chainId:t.caipNetworkId});let n=await r.getUser({chainId:t.caipNetworkId,preferredAccountType:e});this.emit("switchNetwork",n)}}getWalletConnectConnector(){let e=this.connectors.find(e=>e instanceof em);if(!e)throw Error("WalletConnectConnector not found");return e}onConnect(e,t){if(e.length>0){let{address:n,chainId:r}=a.CoreHelperUtil.getAccount(e[0]),o=this.getCaipNetworks().filter(e=>e.chainNamespace===this.namespace).find(e=>e.id.toString()===r?.toString()),s=this.connectors.find(e=>e.id===t);n&&(this.emit("accountChanged",{address:n,chainId:r,connector:s}),this.addConnection({connectorId:t,accounts:e.map(e=>{let{address:t}=a.CoreHelperUtil.getAccount(e);return{address:t}}),caipNetwork:o}))}}onAccountsChanged(e,t,n=!0){if(e.length>0){let{address:n}=a.CoreHelperUtil.getAccount(e[0]),r=this.connectionManager?.getConnection({connectorId:t,connections:this.connections,connectors:this.connectors});n&&G.HelpersUtil.isLowerCaseMatch(this.getConnectorId(i.ConstantsUtil.CHAIN.EVM),t)&&this.emit("accountChanged",{address:n,chainId:r?.caipNetwork?.id,connector:r?.connector}),this.addConnection({connectorId:t,accounts:e.map(e=>{let{address:t}=a.CoreHelperUtil.getAccount(e);return{address:t}}),caipNetwork:r?.caipNetwork})}else n&&this.onDisconnect(t)}onDisconnect(e){this.removeProviderListeners(e),this.deleteConnection(e),G.HelpersUtil.isLowerCaseMatch(this.getConnectorId(i.ConstantsUtil.CHAIN.EVM),e)&&this.emitFirstAvailableConnection(),0===this.connections.length&&this.emit("disconnect")}onChainChanged(e,t){let n="string"==typeof e&&e.startsWith("0x")?eo.hexStringToNumber(e).toString():e.toString(),r=this.connectionManager?.getConnection({connectorId:t,connections:this.connections,connectors:this.connectors}),a=this.getCaipNetworks().filter(e=>e.chainNamespace===this.namespace).find(e=>e.id.toString()===n);r&&this.addConnection({connectorId:t,accounts:r.accounts,caipNetwork:a}),G.HelpersUtil.isLowerCaseMatch(this.getConnectorId(i.ConstantsUtil.CHAIN.EVM),t)&&this.emit("switchNetwork",{chainId:n})}listenProviderEvents(e,t){if(ew.includes(e))return;let n=t=>this.onAccountsChanged(t,e),r=t=>this.onChainChanged(t,e),a=()=>this.onDisconnect(e);this.providerHandlers[e]||(t.on("disconnect",a),t.on("accountsChanged",n),t.on("chainChanged",r),this.providerHandlers[e]={provider:t,disconnect:a,accountsChanged:n,chainChanged:r})}removeProviderListeners(e){if(this.providerHandlers[e]){let{provider:t,disconnect:n,accountsChanged:r,chainChanged:a}=this.providerHandlers[e];t.removeListener("disconnect",n),t.removeListener("accountsChanged",r),t.removeListener("chainChanged",a),this.providerHandlers[e]=null}}emitFirstAvailableConnection(){let e=this.connectionManager?.getConnection({connections:this.connections,connectors:this.connectors});if(e){let[t]=e.accounts;this.emit("accountChanged",{address:t?.address,chainId:e.caipNetwork?.id,connector:e.connector})}}}class eA extends eN{async setUniversalProvider(e){if(!this.namespace)throw Error("UniversalAdapter:setUniversalProvider - namespace is required");return this.addConnector(new em({provider:e,caipNetworks:this.getCaipNetworks(),namespace:this.namespace})),Promise.resolve()}async connect(e){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:Number(e.chainId),provider:this.provider,address:""})}async disconnect(){try{let e=this.getWalletConnectConnector();await e.disconnect(),this.emit("disconnect")}catch(e){console.warn("UniversalAdapter:disconnect - error",e)}return{connections:[]}}syncConnections(){return Promise.resolve()}async getAccounts({namespace:e}){let t=this.provider;return Promise.resolve({accounts:(t?.session?.namespaces?.[e]?.accounts?.map(e=>{let[,,t]=e.split(":");return t}).filter((e,t,n)=>n.indexOf(e)===t)||[]).map(t=>a.CoreHelperUtil.createAccount(e,t,"bip122"===e?"payment":"eoa"))})}async syncConnectors(){return Promise.resolve()}async getBalance(e){if(!(e.caipNetwork&&m.ConstantsUtil.BALANCE_SUPPORTED_CHAINS.includes(e.caipNetwork?.chainNamespace))||e.caipNetwork?.testnet)return{balance:"0.00",symbol:e.caipNetwork?.nativeCurrency.symbol||""};let n=t.ChainController.getAccountData();if(n?.balanceLoading&&e.chainId===t.ChainController.state.activeCaipNetwork?.id)return{balance:n?.balance||"0.00",symbol:n?.balanceSymbol||""};let r=(await t.ChainController.fetchTokenBalance()).find(t=>t.chainId===`${e.caipNetwork?.chainNamespace}:${e.chainId}`&&t.symbol===e.caipNetwork?.nativeCurrency.symbol);return{balance:r?.quantity.numeric||"0.00",symbol:r?.symbol||e.caipNetwork?.nativeCurrency.symbol||""}}async signMessage(e){let{provider:n,message:r,address:a}=e;if(!n)throw Error("UniversalAdapter:signMessage - provider is undefined");return{signature:t.ChainController.state.activeCaipNetwork?.chainNamespace===i.ConstantsUtil.CHAIN.SOLANA?(await n.request({method:"solana_signMessage",params:{message:et.default.encode(new TextEncoder().encode(r)),pubkey:a}},t.ChainController.state.activeCaipNetwork?.caipNetworkId)).signature:await n.request({method:"personal_sign",params:[r,a]},t.ChainController.state.activeCaipNetwork?.caipNetworkId)}}async estimateGas(){return Promise.resolve({gas:BigInt(0)})}async sendTransaction(){return Promise.resolve({hash:""})}walletGetAssets(e){return Promise.resolve({})}async writeContract(){return Promise.resolve({hash:""})}emitFirstAvailableConnection(){}parseUnits(){return 0n}formatUnits(){return"0"}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async syncConnection(){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:1,provider:this.provider,address:""})}async switchNetwork(e){let{caipNetwork:t}=e,n=this.getWalletConnectConnector();if(t.chainNamespace===i.ConstantsUtil.CHAIN.EVM)try{await n.provider?.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,en.toHex)(t.id)}]})}catch(e){if(4902===e.code||32603===e.code||5e3===e.code||e?.data?.originalError?.code===4902)try{await n.provider?.request({method:"wallet_addEthereumChain",params:[{chainId:(0,en.toHex)(t.id),rpcUrls:[t?.rpcUrls.chainDefault?.http],chainName:t.name,nativeCurrency:t.nativeCurrency,blockExplorerUrls:[t.blockExplorers?.default.url]}]})}catch(e){throw Error("Chain is not supported")}}n.provider.setDefaultChain(t.caipNetworkId)}getWalletConnectProvider(){let e=this.connectors.find(e=>"WALLET_CONNECT"===e.type);return e?.provider}}let eE=["email","socials","swaps","onramp","activity","reownBranding","multiWallet","emailCapture","payWithExchange","payments","reownAuthentication"],ev={email:{apiFeatureName:"social_login",localFeatureName:"email",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.includes("email")},processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.email:!!e},socials:{apiFeatureName:"social_login",localFeatureName:"socials",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.length>0&&t.filter(e=>"email"!==e)},processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:"boolean"==typeof e?!!e&&m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:e},swaps:{apiFeatureName:"swap",localFeatureName:"swaps",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.length>0&&t},processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:"boolean"==typeof e?!!e&&m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:e},onramp:{apiFeatureName:"onramp",localFeatureName:"onramp",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>{if(!e?.config)return!1;let t=e.config;return!!e.isEnabled&&t.length>0&&t},processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:"boolean"==typeof e?!!e&&m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:e},activity:{apiFeatureName:"activity",localFeatureName:"history",returnType:!1,isLegacy:!0,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.activity:!!e},reownBranding:{apiFeatureName:"reown_branding",localFeatureName:"reownBranding",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownBranding:!!e},emailCapture:{apiFeatureName:"email_capture",localFeatureName:"emailCapture",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>e.isEnabled&&(e.config??[]),processFallback:e=>!1},multiWallet:{apiFeatureName:"multi_wallet",localFeatureName:"multiWallet",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:()=>m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.multiWallet},payWithExchange:{apiFeatureName:"fund_from_exchange",localFeatureName:"payWithExchange",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:()=>m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payWithExchange},payments:{apiFeatureName:"payments",localFeatureName:"payments",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:()=>m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payments},reownAuthentication:{apiFeatureName:"reown_authentication",localFeatureName:"reownAuthentication",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:e=>!!e.isEnabled,processFallback:e=>void 0===e?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownAuthentication:!!e}},ef={localSettingsOverridden:new Set,getApiConfig:(e,t)=>t?.find(t=>t.id===e),addWarning(e,t){if(void 0!==e){let e=ev[t],n=e.isLegacy?`"features.${e.localFeatureName}" (now "${t}")`:`"features.${t}"`;this.localSettingsOverridden.add(n)}},processFeature(e,t,n,r,a){let o=ev[e],s=t[o.localFeatureName];if(a&&!o.isAvailableOnBasic)return!1;if(r){let t=this.getApiConfig(o.apiFeatureName,n);return t?.config===null?this.processFallbackFeature(e,s):!!t?.config&&(void 0!==s&&this.addWarning(s,e),this.processApiFeature(e,t))}return this.processFallbackFeature(e,s)},processApiFeature:(e,t)=>ev[e].processApi(t),processFallbackFeature:(e,t)=>ev[e].processFallback(t),async fetchRemoteFeatures(e){let t=e.basic??!1,n=e.features||{};this.localSettingsOverridden.clear();let r=null,a=!1;try{a=null!=(r=await C.ApiController.fetchProjectConfig())}catch(e){console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.",e)}let o=a&&!t?m.ConstantsUtil.DEFAULT_REMOTE_FEATURES:m.ConstantsUtil.DEFAULT_REMOTE_FEATURES_DISABLED;try{for(let e of eE){let s=this.processFeature(e,n,r,a,t);Object.assign(o,{[e]:s})}}catch(e){return console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.",e),m.ConstantsUtil.DEFAULT_REMOTE_FEATURES}if(a&&this.localSettingsOverridden.size>0){let e=`Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;d.AlertController.open({debugMessage:z.debugMessage(e)},"warning")}return o}};class ey{constructor(e){this.chainNamespaces=[],this.features={},this.remoteFeatures={},this.reportedAlertErrors={},this.getCaipNetwork=(e,n)=>{if(e){let r=t.ChainController.getCaipNetworks(e)?.find(e=>e.id===n);if(r)return r;let a=t.ChainController.getNetworkData(e)?.caipNetwork;if(a)return a;let o=t.ChainController.getRequestedCaipNetworks(e);return o.filter(t=>t.chainNamespace===e)?.[0]}return t.ChainController.state.activeCaipNetwork||this.defaultCaipNetwork},this.getCaipNetworkId=()=>{let e=this.getCaipNetwork();if(e)return e.id},this.getCaipNetworks=e=>t.ChainController.getCaipNetworks(e),this.getActiveChainNamespace=()=>t.ChainController.state.activeChain,this.setRequestedCaipNetworks=(e,n)=>{t.ChainController.setRequestedCaipNetworks(e,n)},this.getApprovedCaipNetworkIds=()=>t.ChainController.getAllApprovedCaipNetworkIds(),this.getCaipAddress=e=>t.ChainController.state.activeChain!==e&&e?t.ChainController.state.chains.get(e)?.accountState?.caipAddress:t.ChainController.state.activeCaipAddress,this.setClientId=e=>{h.BlockchainApiController.setClientId(e)},this.getProvider=e=>R.getProvider(e),this.getProviderType=e=>R.getProviderId(e),this.getPreferredAccountType=e=>(0,B.getPreferredAccountType)(e),this.setCaipAddress=(e,n,r=!1)=>{t.ChainController.setAccountProp("caipAddress",e,n,r),t.ChainController.setAccountProp("address",a.CoreHelperUtil.getPlainAddress(e),n,r)},this.setBalance=(e,n,r)=>{t.ChainController.setAccountProp("balance",e,r),t.ChainController.setAccountProp("balanceSymbol",n,r)},this.setProfileName=(e,n)=>{t.ChainController.setAccountProp("profileName",e,n)},this.setProfileImage=(e,n)=>{t.ChainController.setAccountProp("profileImage",e,n)},this.setUser=(e,n)=>{t.ChainController.setAccountProp("user",e,n)},this.resetAccount=e=>{t.ChainController.resetAccount(e)},this.setCaipNetwork=e=>{t.ChainController.setActiveCaipNetwork(e)},this.setCaipNetworkOfNamespace=(e,n)=>{t.ChainController.setChainNetworkData(n,{caipNetwork:e})},this.setStatus=(e,n)=>{t.ChainController.setAccountProp("status",e,n),r.ConnectorController.isConnected()?A.StorageUtil.setConnectionStatus("connected"):A.StorageUtil.setConnectionStatus("disconnected")},this.getAddressByChainNamespace=e=>t.ChainController.getAccountData(e)?.address,this.setConnectors=e=>{let t=[...r.ConnectorController.state.allConnectors,...e];r.ConnectorController.setConnectors(t)},this.setConnections=(e,t)=>{A.StorageUtil.setConnections(e,t),n.ConnectionController.setConnections(e,t)},this.fetchIdentity=e=>h.BlockchainApiController.fetchIdentity(e),this.getReownName=e=>y.getNamesForAddress(e),this.getConnectors=()=>r.ConnectorController.getConnectors(),this.getConnectorImage=e=>p.AssetUtil.getConnectorImage(e),this.getConnections=e=>this.remoteFeatures.multiWallet?u.ConnectionControllerUtil.getConnectionsData(e).connections:(d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.getRecentConnections=e=>this.remoteFeatures.multiWallet?u.ConnectionControllerUtil.getConnectionsData(e).recentConnections:(d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.switchConnection=async e=>{this.remoteFeatures.multiWallet?await n.ConnectionController.switchConnection(e):d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.deleteConnection=e=>{this.remoteFeatures.multiWallet?(A.StorageUtil.deleteAddressFromConnection(e),n.ConnectionController.syncStorageConnections()):d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.setConnectedWalletInfo=(e,n)=>{let r=R.getProviderId(n),a=e?{...e,type:r}:void 0;t.ChainController.setAccountProp("connectedWalletInfo",a,n)},this.getIsConnectedState=()=>!!t.ChainController.state.activeCaipAddress,this.addAddressLabel=(e,n,r)=>{let a=t.ChainController.getAccountData(r)?.addressLabels||{};t.ChainController.setAccountProp("addressLabels",{...a,[e]:n},r)},this.removeAddressLabel=(e,n)=>{let r=t.ChainController.getAccountData(n)?.addressLabels||{};t.ChainController.setAccountProp("addressLabels",{...r,[e]:void 0},n)},this.getAddress=e=>{let n=e||t.ChainController.state.activeChain;return t.ChainController.getAccountData(n)?.address},this.setApprovedCaipNetworksData=e=>t.ChainController.setApprovedCaipNetworksData(e),this.resetNetwork=e=>{t.ChainController.resetNetwork(e)},this.addConnector=e=>{r.ConnectorController.addConnector(e)},this.resetWcConnection=()=>{n.ConnectionController.resetWcConnection()},this.setAddressExplorerUrl=(e,n)=>{t.ChainController.setAccountProp("addressExplorerUrl",e,n)},this.setSmartAccountDeployed=(e,n)=>{t.ChainController.setAccountProp("smartAccountDeployed",e,n)},this.setPreferredAccountType=(e,n)=>{t.ChainController.setAccountProp("preferredAccountType",e,n)},this.setEIP6963Enabled=e=>{o.OptionsController.setEIP6963Enabled(e)},this.handleUnsafeRPCRequest=()=>{this.isOpen()?this.isTransactionStackEmpty()||this.redirect("ApproveTransaction"):this.open({view:"ApproveTransaction"})},this.options=e,this.version=e.sdkVersion,this.caipNetworks=this.extendCaipNetworks(e),this.chainNamespaces=this.getChainNamespacesSet(e.adapters,this.caipNetworks),this.defaultCaipNetwork=this.extendDefaultCaipNetwork(e),this.chainAdapters=this.createAdapters(e.adapters),this.readyPromise=this.initialize(e),Q.checkSDKVersion(e.sdkVersion)}getChainNamespacesSet(e,t){let n=e?.map(e=>e.namespace).filter(e=>!!e);return n?.length?[...new Set(n)]:[...new Set(t?.map(e=>e.chainNamespace))]}async initialize(t){if(this.initializeProjectSettings(t),this.initControllers(t),await this.initChainAdapters(),this.sendInitializeEvent(t),o.OptionsController.state.enableReconnect?(await this.syncExistingConnection(),await this.syncAdapterConnections()):await this.unSyncExistingConnection(),this.remoteFeatures=await ef.fetchRemoteFeatures(t),o.OptionsController.setRemoteFeatures(this.remoteFeatures),this.remoteFeatures.onramp&&S.setOnrampProviders(this.remoteFeatures.onramp),(o.OptionsController.state.remoteFeatures?.email||Array.isArray(o.OptionsController.state.remoteFeatures?.socials)&&o.OptionsController.state.remoteFeatures?.socials.length>0)&&await this.checkAllowedOrigins(),o.OptionsController.state.features?.reownAuthentication||o.OptionsController.state.remoteFeatures?.reownAuthentication){let{ReownAuthentication:t}=await e.A(432297),n=o.OptionsController.state.siwx;n instanceof t||(n&&console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden."),o.OptionsController.setSIWX(new t))}}async openSend(e){let n=e.namespace||t.ChainController.state.activeChain,r=this.getCaipAddress(n),a=this.getCaipNetwork(n)?.id;if(!r)throw Error("openSend: caipAddress not found");if(a?.toString()!==e.chainId.toString()){let r=t.ChainController.getCaipNetworkById(e.chainId,n);if(!r)throw Error(`openSend: caipNetwork with chainId ${e.chainId} not found`);await this.switchNetwork(r,{throwOnFailure:!0})}try{let t=ee.getTokenSymbolByAddress(e.assetAddress);t&&await C.ApiController.fetchTokenImages([t])}catch{}return await T.ModalController.open({view:"WalletSend",data:{send:e}}),new Promise((e,t)=>{let n=M.SendController.subscribeKey("hash",t=>{t&&(a(),e({hash:t}))}),r=T.ModalController.subscribe(e=>{e.open||(a(),t(Error("Modal closed")))}),a=this.createCleanupHandler([n,r])})}toModalOptions(){return{isSwap:function(e){return e?.view==="Swap"},isSend:function(e){return e?.view==="WalletSend"}}}async checkAllowedOrigins(){try{let e=await C.ApiController.fetchAllowedOrigins();if(!a.CoreHelperUtil.isClient())return;let t=window.location.origin;ep.isOriginAllowed(t,e,eu)||d.AlertController.open($.ORIGIN_NOT_ALLOWED,"error")}catch(e){if(!(e instanceof Error))return;switch(e.message){case"RATE_LIMITED":d.AlertController.open($.RATE_LIMITED_APP_CONFIGURATION,"error");break;case"SERVER_ERROR":{let t=e.cause instanceof Error?e.cause:e;d.AlertController.open({displayMessage:$.SERVER_ERROR_APP_CONFIGURATION.displayMessage,debugMessage:$.SERVER_ERROR_APP_CONFIGURATION.debugMessage(t.message)},"error")}}}}createCleanupHandler(e){return()=>{e.forEach(e=>{try{e()}catch{}})}}sendInitializeEvent(e){let{...t}=e;delete t.adapters,delete t.universalProvider,I.EventsController.sendEvent({type:"track",event:"INITIALIZE",properties:{...t,networks:e.networks.map(e=>e.id),siweConfig:{options:e.siweConfig?.options||{}}}})}initControllers(e){this.initializeOptionsController(e),this.initializeChainController(e),this.initializeThemeController(e),this.initializeConnectionController(e),this.initializeConnectorController()}initializeThemeController(e){e.themeMode&&F.ThemeController.setThemeMode(e.themeMode),e.themeVariables&&F.ThemeController.setThemeVariables(e.themeVariables)}initializeChainController(e){if(!this.connectionControllerClient||!this.networkControllerClient)throw Error("ConnectionControllerClient and NetworkControllerClient must be set");t.ChainController.initialize(e.adapters??[],this.caipNetworks,{connectionControllerClient:this.connectionControllerClient,networkControllerClient:this.networkControllerClient});let n=this.getDefaultNetwork();n&&t.ChainController.setActiveCaipNetwork(n)}initializeConnectionController(e){n.ConnectionController.initialize(e.adapters??[]),n.ConnectionController.setWcBasic(e.basic??!1)}initializeConnectorController(){r.ConnectorController.initialize(this.chainNamespaces)}initializeProjectSettings(e){o.OptionsController.setProjectId(e.projectId),o.OptionsController.setSdkVersion(e.sdkVersion)}initializeOptionsController(e){o.OptionsController.setDebug(!1!==e.debug),o.OptionsController.setEnableWalletGuide(!1!==e.enableWalletGuide),o.OptionsController.setEnableWallets(!1!==e.enableWallets),o.OptionsController.setEIP6963Enabled(!1!==e.enableEIP6963),o.OptionsController.setEnableNetworkSwitch(!1!==e.enableNetworkSwitch),o.OptionsController.setEnableReconnect(!1!==e.enableReconnect),o.OptionsController.setEnableMobileFullScreen(!0===e.enableMobileFullScreen),o.OptionsController.setEnableAuthLogger(!1!==e.enableAuthLogger),o.OptionsController.setCustomRpcUrls(e.customRpcUrls),o.OptionsController.setEnableEmbedded(e.enableEmbedded),o.OptionsController.setAllWallets(e.allWallets),o.OptionsController.setIncludeWalletIds(e.includeWalletIds),o.OptionsController.setExcludeWalletIds(e.excludeWalletIds),o.OptionsController.setFeaturedWalletIds(e.featuredWalletIds),o.OptionsController.setTokens(e.tokens),o.OptionsController.setTermsConditionsUrl(e.termsConditionsUrl),o.OptionsController.setPrivacyPolicyUrl(e.privacyPolicyUrl),o.OptionsController.setCustomWallets(e.customWallets),o.OptionsController.setFeatures(e.features),o.OptionsController.setAllowUnsupportedChain(e.allowUnsupportedChain),o.OptionsController.setUniversalProviderConfigOverride(e.universalProviderConfigOverride),o.OptionsController.setPreferUniversalLinks(e.experimental_preferUniversalLinks),o.OptionsController.setDefaultAccountTypes(e.defaultAccountTypes);let t=this.getDefaultMetaData();if(!e.metadata&&t&&(e.metadata=t),o.OptionsController.setMetadata(e.metadata),o.OptionsController.setDisableAppend(e.disableAppend),o.OptionsController.setEnableEmbedded(e.enableEmbedded),o.OptionsController.setSIWX(e.siwx),this.features=o.OptionsController.state.features??{},!e.projectId)return void d.AlertController.open($.PROJECT_ID_NOT_CONFIGURED,"error");if(e.adapters?.find(e=>e.namespace===i.ConstantsUtil.CHAIN.EVM)&&e.siweConfig){if(e.siwx)throw Error("Cannot set both `siweConfig` and `siwx` options");o.OptionsController.setSIWX(e.siweConfig.mapToSIWX())}}getDefaultMetaData(){return a.CoreHelperUtil.isClient()?{name:document.getElementsByTagName("title")?.[0]?.textContent||"",description:document.querySelector('meta[property="og:description"]')?.content||"",url:window.location.origin,icons:[document.querySelector('link[rel~="icon"]')?.href||""]}:null}setUnsupportedNetwork(e){let n=this.getActiveChainNamespace();if(n){let r=K.CaipNetworksUtil.getUnsupportedNetwork(`${n}:${e}`);t.ChainController.setActiveCaipNetwork(r)}}getDefaultNetwork(){return K.CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork)}extendCaipNetwork(e,t){return K.CaipNetworksUtil.extendCaipNetwork(e,{customNetworkImageUrls:t.chainImages,projectId:t.projectId})}extendCaipNetworks(e){return K.CaipNetworksUtil.extendCaipNetworks(e.networks,{customNetworkImageUrls:e.chainImages,customRpcUrls:e.customRpcUrls,projectId:e.projectId})}extendDefaultCaipNetwork(e){let t=e.networks.find(t=>t.id===e.defaultNetwork?.id);return t?K.CaipNetworksUtil.extendCaipNetwork(t,{customNetworkImageUrls:e.chainImages,customRpcUrls:e.customRpcUrls,projectId:e.projectId}):void 0}async disconnectConnector(e,n){try{this.setLoading(!0,e);let r={connections:[]},a=this.getAdapter(e);return(t.ChainController.state.chains.get(e)?.accountState?.caipAddress||!o.OptionsController.state.enableReconnect)&&a?.disconnect&&(r=await a.disconnect({id:n})),this.setLoading(!1,e),r}catch(t){throw this.setLoading(!1,e),Error(`Failed to disconnect chains: ${t.message}`)}}createClients(){this.connectionControllerClient={connectWalletConnect:async()=>{let e=t.ChainController.state.activeChain,r=this.getAdapter(e),a=this.getCaipNetwork(e)?.id,o=n.ConnectionController.getConnections(e),s=this.remoteFeatures.multiWallet,i=o.length>0;if(!r)throw Error("Adapter not found");let l=await r.connectWalletConnect(a);i&&s||this.close(),this.setClientId(l?.clientId||null),A.StorageUtil.setConnectedNamespaces([...t.ChainController.state.chains.keys()]),await this.syncWalletConnectAccount(),await L.SIWXUtil.initializeIfEnabled()},connectExternal:async e=>{let t=await this.onConnectExternal(e);return await this.connectInactiveNamespaces(e,t),t?{address:t.address}:void 0},reconnectExternal:async({id:e,info:n,type:r,provider:a})=>{let o=t.ChainController.state.activeChain,s=this.getAdapter(o);if(!o)throw Error("reconnectExternal: namespace not found");if(!s)throw Error("reconnectExternal: adapter not found");s?.reconnect&&(await s?.reconnect({id:e,info:n,type:r,provider:a,chainId:this.getCaipNetwork()?.id}),A.StorageUtil.addConnectedNamespace(o),this.syncConnectedWalletInfo(o))},disconnectConnector:async e=>{await this.disconnectConnector(e.namespace,e.id)},disconnect:async e=>{let{id:a,chainNamespace:o,initialDisconnect:s}=e||{},l=o||t.ChainController.state.activeChain,c=r.ConnectorController.getConnectorId(l),d=a===i.ConstantsUtil.CONNECTOR_ID.AUTH||c===i.ConstantsUtil.CONNECTOR_ID.AUTH,C=a===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT||c===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;try{let e=Array.from(t.ChainController.state.chains.keys()),i=o?[o]:e;(C||d)&&(i=e);let l=i.map(async e=>{let t=r.ConnectorController.getConnectorId(e),n=await this.disconnectConnector(e,a||t);n&&(d&&A.StorageUtil.deleteConnectedSocialProvider(),n.connections.forEach(t=>{A.StorageUtil.addDisconnectedConnectorId(t.connectorId,e)})),s&&this.onDisconnectNamespace({chainNamespace:e,closeModal:!1})}),c=await Promise.allSettled(l);M.SendController.resetSend(),n.ConnectionController.resetWcConnection(),L.SIWXUtil.getSIWX()?.signOutOnDisconnect&&await L.SIWXUtil.clearSessions(),r.ConnectorController.setFilterByNamespace(void 0),n.ConnectionController.syncStorageConnections();let p=c.filter(e=>"rejected"===e.status);if(p.length>0)throw Error(p.map(e=>e.reason.message).join(", "));I.EventsController.sendEvent({type:"track",event:"DISCONNECT_SUCCESS",properties:{namespace:o||"all"}})}catch(e){throw Error(`Failed to disconnect chains: ${e.message}`)}},checkInstalled:e=>e?e.some(e=>!!window.ethereum?.[String(e)]):!!window.ethereum,signMessage:async e=>{let n=t.ChainController.state.activeChain,r=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("signMessage: namespace not found");if(!r)throw Error("signMessage: adapter not found");let a=this.getAddress(n);if(!a)throw Error("signMessage: address not found");let o=await r?.signMessage({message:e,address:a,provider:R.getProvider(n)});return o?.signature||""},sendTransaction:async e=>{let t=e.chainNamespace;if(!t)throw Error("sendTransaction: namespace not found");if(m.ConstantsUtil.SEND_SUPPORTED_NAMESPACES.includes(t)){let n=this.getAdapter(t);if(!n)throw Error("sendTransaction: adapter not found");let r=R.getProvider(t),a=await n?.sendTransaction({...e,caipNetwork:this.getCaipNetwork(),provider:r});return a?.hash||""}return""},estimateGas:async e=>{let t=e.chainNamespace;if(t===i.ConstantsUtil.CHAIN.EVM){let n=this.getAdapter(t);if(!n)throw Error("estimateGas: adapter is required but got undefined");let r=R.getProvider(t),a=this.getCaipNetwork();if(!a)throw Error("estimateGas: caipNetwork is required but got undefined");let o=await n?.estimateGas({...e,provider:r,caipNetwork:a});return o?.gas||0n}return 0n},getEnsAvatar:async()=>{let e=t.ChainController.state.activeChain;if(!e)throw Error("getEnsAvatar: namespace is required but got undefined");let n=this.getAddress(e);if(!n)throw Error("getEnsAvatar: address not found");await this.syncIdentity({address:n,chainId:Number(this.getCaipNetwork()?.id),chainNamespace:e});let r=t.ChainController.getAccountData();return r?.profileImage||!1},getEnsAddress:async e=>await ep.resolveReownName(e),writeContract:async e=>{let n=t.ChainController.state.activeChain,r=this.getAdapter(n);if(!n)throw Error("writeContract: namespace is required but got undefined");if(!r)throw Error("writeContract: adapter is required but got undefined");let a=this.getCaipNetwork(),o=this.getCaipAddress(),s=R.getProvider(n);if(!a||!o)throw Error("writeContract: caipNetwork or caipAddress is required but got undefined");let i=await r?.writeContract({...e,caipNetwork:a,provider:s,caipAddress:o});return i?.hash},parseUnits:(e,n)=>{let r=this.getAdapter(t.ChainController.state.activeChain);if(!r)throw Error("parseUnits: adapter is required but got undefined");return r?.parseUnits({value:e,decimals:n})??0n},formatUnits:(e,n)=>{let r=this.getAdapter(t.ChainController.state.activeChain);if(!r)throw Error("formatUnits: adapter is required but got undefined");return r?.formatUnits({value:e,decimals:n})??"0"},getCapabilities:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("getCapabilities: adapter is required but got undefined");return await n?.getCapabilities(e)},grantPermissions:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("grantPermissions: adapter is required but got undefined");return await n?.grantPermissions(e)},revokePermissions:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("revokePermissions: adapter is required but got undefined");return n?.revokePermissions?await n.revokePermissions(e):"0x"},walletGetAssets:async e=>{let n=this.getAdapter(t.ChainController.state.activeChain);if(!n)throw Error("walletGetAssets: adapter is required but got undefined");return await n?.walletGetAssets(e)??{}},updateBalance:e=>{let t=this.getAddress(e),n=this.getCaipNetwork(e);n&&t&&this.updateNativeBalance(t,n?.id,e)}},this.networkControllerClient={switchCaipNetwork:async e=>await this.switchCaipNetwork(e),getApprovedCaipNetworksData:async()=>this.getApprovedCaipNetworksData()},n.ConnectionController.setClient(this.connectionControllerClient)}async onConnectExternal(e){let n=t.ChainController.state.activeChain,a=e.chain||n,o=this.getAdapter(a),s=!0;if(e.type===Z.ConstantsUtil.CONNECTOR_TYPE_AUTH&&i.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(e=>r.ConnectorController.getConnectorId(e)===i.ConstantsUtil.CONNECTOR_ID.AUTH)&&e.chain!==n&&(s=!1),e.chain&&e.chain!==n&&!e.caipNetwork){let t=this.getCaipNetworks().find(t=>t.chainNamespace===e.chain);t&&s&&this.setCaipNetwork(t)}if(!a)throw Error("connectExternal: namespace not found");if(!o)throw Error("connectExternal: adapter not found");let l=this.getCaipNetwork(a),c=e.caipNetwork||l,d=await o.connect({id:e.id,address:e.address,info:e.info,type:e.type,provider:e.provider,socialUri:e.socialUri,chainId:e.caipNetwork?.id||l?.id,rpcUrl:e.caipNetwork?.rpcUrls?.default?.http?.[0]||l?.rpcUrls?.default?.http?.[0]});if(d)return A.StorageUtil.addConnectedNamespace(a),this.syncProvider({...d,chainNamespace:a}),this.setStatus("connected",a),this.syncConnectedWalletInfo(a),A.StorageUtil.removeDisconnectedConnectorId(e.id,a),{address:d.address,connectedCaipNetwork:c}}async connectInactiveNamespaces(e,n){let r=e.type===Z.ConstantsUtil.CONNECTOR_TYPE_AUTH,a=G.HelpersUtil.getOtherAuthNamespaces(n?.connectedCaipNetwork?.chainNamespace),o=t.ChainController.state.activeCaipNetwork,s=this.getAdapter(o?.chainNamespace),i=R.getProvider(o?.chainNamespace);r&&(await Promise.all(a.map(async t=>{try{let n=R.getProvider(t),r=this.getCaipNetwork(t),a=this.getAdapter(t);await a?.connect({...e,provider:n,socialUri:void 0,chainId:r?.id,rpcUrl:r?.rpcUrls?.default?.http?.[0]})&&(A.StorageUtil.addConnectedNamespace(t),A.StorageUtil.removeDisconnectedConnectorId(e.id,t),this.setStatus("connected",t),this.syncConnectedWalletInfo(t))}catch(e){d.AlertController.warn(Y.displayMessage,Y.debugMessage(t,e instanceof Error?e.message:void 0),Y.code)}})),o&&await s?.switchNetwork({caipNetwork:o,provider:i,providerType:e.type}))}getApprovedCaipNetworksData(){if(R.getProviderId(t.ChainController.state.activeChain)===Z.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT){let e=this.universalProvider?.session?.namespaces;return{supportsAllNetworks:this.universalProvider?.session?.peer?.metadata.name==="MetaMask Wallet",approvedCaipNetworkIds:this.getChainsFromNamespaces(e)}}return{supportsAllNetworks:!0,approvedCaipNetworkIds:[]}}async switchCaipNetwork(e){let n=e.chainNamespace;if(this.getAddressByChainNamespace(e.chainNamespace)){let r=R.getProvider(n),a=R.getProviderId(n);if(e.chainNamespace===t.ChainController.state.activeChain){let t=this.getAdapter(n);await t?.switchNetwork({caipNetwork:e,provider:r,providerType:a})}else if(this.setCaipNetwork(e),a===Z.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT)this.syncWalletConnectAccount();else{let t=this.getAddressByChainNamespace(n);t&&this.syncAccount({address:t,chainId:e.id,chainNamespace:n})}}else this.setCaipNetwork(e)}getChainsFromNamespaces(e={}){return Object.values(e).flatMap(e=>Array.from(new Set([...e.chains||[],...e.accounts.map(e=>{let{chainId:t,chainNamespace:n}=c.ParseUtil.parseCaipAddress(e);return`${n}:${t}`})])))}createAdapters(e){return this.createClients(),this.chainNamespaces.reduce((t,n)=>{let r=e?.find(e=>e.namespace===n);return r?(r.construct({namespace:n,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:e})=>e===n)}),t[n]=r):t[n]=new eA({namespace:n,networks:this.getCaipNetworks()}),t},{})}async initChainAdapter(e){this.onConnectors(e),this.listenAdapter(e),await this.chainAdapters?.[e].syncConnectors(this.options,this),await this.createUniversalProviderForAdapter(e)}async initChainAdapters(){await Promise.all(this.chainNamespaces.map(async e=>{await this.initChainAdapter(e)}))}onConnectors(e){let t=this.getAdapter(e);t?.on("connectors",this.setConnectors.bind(this))}listenAdapter(e){let r=this.getAdapter(e);if(!r)return;let a=A.StorageUtil.getConnectionStatus();!1===o.OptionsController.state.enableReconnect?this.setStatus("disconnected",e):"connected"===a?this.setStatus("connecting",e):("disconnected"===a&&A.StorageUtil.clearAddressCache(),this.setStatus(a,e)),r.on("switchNetwork",({address:n,chainId:r})=>{let a=this.getCaipNetworks().find(e=>e.id.toString()===r.toString()||e.caipNetworkId.toString()===r.toString()),o=t.ChainController.state.activeChain===e,s=t.ChainController.state.chains.get(e)?.accountState?.address;if(a){let t=o&&n?n:s;t&&this.syncAccount({address:t,chainId:a.id,chainNamespace:e})}else this.setUnsupportedNetwork(r)}),r.on("disconnect",()=>{let t=this.remoteFeatures.multiWallet,r=Array.from(n.ConnectionController.state.connections.values()).flat();this.onDisconnectNamespace({chainNamespace:e,closeModal:!t||0===r.length})}),r.on("connections",t=>{this.setConnections(t,e)}),r.on("pendingTransactions",()=>{let n=this.getAddress(e),r=t.ChainController.state.activeCaipNetwork;n&&r?.id&&this.updateNativeBalance(n,r.id,r.chainNamespace)}),r.on("accountChanged",({address:n,chainId:r,connector:a})=>{this.handlePreviousConnectorConnection(a);let o=t.ChainController.state.activeChain===e;a?.provider&&(this.syncProvider({id:a.id,type:a.type,provider:a?.provider,chainNamespace:e}),this.syncConnectedWalletInfo(e));let s=t.ChainController.getNetworkData(e)?.caipNetwork?.id,i=r||s;o&&i?this.syncAccount({address:n,chainId:i,chainNamespace:e}):!o&&i?(this.syncAccountInfo(n,i,e),this.syncBalance({address:n,chainId:i,chainNamespace:e})):this.syncAccountInfo(n,r,e),A.StorageUtil.addConnectedNamespace(e)})}async handlePreviousConnectorConnection(e){let t=e?.chain,a=e?.id,s=r.ConnectorController.getConnectorId(t),i=o.OptionsController.state.remoteFeatures?.multiWallet,l=s!==a,c=t&&a&&s&&l&&!i;try{c&&await n.ConnectionController.disconnect({id:s,namespace:t})}catch(e){console.warn("Error disconnecting previous connector",e)}}async createUniversalProviderForAdapter(e){await this.getUniversalProvider(),this.universalProvider&&await this.chainAdapters?.[e]?.setUniversalProvider?.(this.universalProvider)}async syncExistingConnection(){await Promise.allSettled(this.chainNamespaces.map(e=>this.syncNamespaceConnection(e)))}async unSyncExistingConnection(){try{await Promise.allSettled(this.chainNamespaces.map(e=>n.ConnectionController.disconnect({namespace:e,initialDisconnect:!0})))}catch(e){console.error("Error disconnecting existing connections:",e)}}async reconnectWalletConnect(){await this.syncWalletConnectAccount();let e=this.getAddress();this.getCaipAddress()||A.StorageUtil.deleteRecentWallet();let t=A.StorageUtil.getRecentWallet();I.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:e,properties:{method:a.CoreHelperUtil.isMobile()?"mobile":"qrcode",name:t?.name||"Unknown",reconnect:!0,view:v.RouterController.state.view,walletRank:t?.order}})}async syncNamespaceConnection(e){try{e===i.ConstantsUtil.CHAIN.EVM&&a.CoreHelperUtil.isSafeApp()&&r.ConnectorController.setConnectorId(i.ConstantsUtil.CONNECTOR_ID.SAFE,e);let t=r.ConnectorController.getConnectorId(e);switch(this.setStatus("connecting",e),t){case i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:await this.reconnectWalletConnect();break;case i.ConstantsUtil.CONNECTOR_ID.AUTH:break;default:await this.syncAdapterConnection(e)}}catch(t){console.warn("AppKit couldn't sync existing connection",t),this.setStatus("disconnected",e)}}onDisconnectNamespace(e){let{chainNamespace:n,closeModal:a}=e||{};t.ChainController.resetAccount(n),t.ChainController.resetNetwork(n),A.StorageUtil.removeConnectedNamespace(n);let o=Array.from(t.ChainController.state.chains.keys());(n?[n]:o).forEach(e=>A.StorageUtil.addDisconnectedConnectorId(r.ConnectorController.getConnectorId(e)||"",e)),r.ConnectorController.removeConnectorId(n),R.resetChain(n),this.setUser(null,n),this.setStatus("disconnected",n),this.setConnectedWalletInfo(null,n),!1!==a&&T.ModalController.close()}async syncAdapterConnections(){await Promise.allSettled(this.chainNamespaces.map(e=>{let t=this.getAdapter(e),n=this.getCaipAddress(e),r=this.getCaipNetwork(e);return t?.syncConnections({connectToFirstConnector:!n,caipNetwork:r})}))}async syncAdapterConnection(e){let t=this.getAdapter(e),n=this.getCaipNetwork(e),a=r.ConnectorController.getConnectorId(e),o=r.ConnectorController.getConnectors(e).find(e=>e.id===a);try{if(!t||!o)throw Error(`Adapter or connector not found for namespace ${e}`);if(!n?.id)throw Error("CaipNetwork not found");let r=await t?.syncConnection({namespace:e,id:o.id,chainId:n.id,rpcUrl:n?.rpcUrls?.default?.http?.[0]});r?(this.syncProvider({...r,chainNamespace:e}),await this.syncAccount({...r,chainNamespace:e}),this.setStatus("connected",e),I.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:r.address,properties:{method:"browser",name:o.info?.name||o.name||"Unknown",reconnect:!0,view:v.RouterController.state.view,walletRank:void 0}})):this.setStatus("disconnected",e)}catch(t){this.onDisconnectNamespace({chainNamespace:e,closeModal:!1})}}async syncWalletConnectAccount(){let e=Object.keys(this.universalProvider?.session?.namespaces||{}),n=this.chainNamespaces.map(async n=>{let a=this.getAdapter(n);if(!a)return;let o=this.universalProvider?.session?.namespaces?.[n]?.accounts||[],s=t.ChainController.state.activeCaipNetwork?.id,l=o.find(e=>{let{chainId:t}=c.ParseUtil.parseCaipAddress(e);return t===s?.toString()})||o[0];if(l){let e=c.ParseUtil.validateCaipAddress(l),{chainId:o,address:s}=c.ParseUtil.parseCaipAddress(e);if(R.setProviderId(n,Z.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT),this.caipNetworks&&t.ChainController.state.activeCaipNetwork&&a.namespace!==i.ConstantsUtil.CHAIN.EVM){let e=a.getWalletConnectProvider({caipNetworks:this.getCaipNetworks(),provider:this.universalProvider,activeCaipNetwork:t.ChainController.state.activeCaipNetwork});R.setProvider(n,e)}else R.setProvider(n,this.universalProvider);r.ConnectorController.setConnectorId(i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,n),A.StorageUtil.addConnectedNamespace(n),await this.syncAccount({address:s,chainId:o,chainNamespace:n})}else e.includes(n)&&this.setStatus("disconnected",n);this.syncConnectedWalletInfo(n),await t.ChainController.setApprovedCaipNetworksData(n)});await Promise.all(n)}syncProvider({type:e,provider:t,id:n,chainNamespace:a}){R.setProviderId(a,e),R.setProvider(a,t),r.ConnectorController.setConnectorId(n,a)}async syncAccount(e){let n=e.chainNamespace===t.ChainController.state.activeChain,r=t.ChainController.getCaipNetworkByNamespace(e.chainNamespace,e.chainId),{address:a,chainId:s,chainNamespace:l}=e,{chainId:d}=A.StorageUtil.getActiveNetworkProps(),C=s||d,p=t.ChainController.state.activeCaipNetwork?.name===i.ConstantsUtil.UNSUPPORTED_NETWORK_NAME,h=t.ChainController.getNetworkProp("supportsAllNetworks",l);if(this.setStatus("connected",l),(!p||h)&&C){let e=this.getCaipNetworks().find(e=>e.id.toString()===C.toString()),d=this.getCaipNetworks().find(e=>e.chainNamespace===l);if(!h&&!e&&!d){let t=this.getApprovedCaipNetworkIds()||[],n=t.find(e=>c.ParseUtil.parseCaipNetworkId(e)?.chainId===C.toString()),r=t.find(e=>c.ParseUtil.parseCaipNetworkId(e)?.chainNamespace===l);e=this.getCaipNetworks().find(e=>e.caipNetworkId===n),d=this.getCaipNetworks().find(e=>e.caipNetworkId===r||"deprecatedCaipNetworkId"in e&&e.deprecatedCaipNetworkId===r)}let p=e||d;p?.chainNamespace===t.ChainController.state.activeChain?o.OptionsController.state.enableNetworkSwitch&&!o.OptionsController.state.allowUnsupportedChain&&t.ChainController.state.activeCaipNetwork?.name===i.ConstantsUtil.UNSUPPORTED_NETWORK_NAME?t.ChainController.showUnsupportedChainUI():this.setCaipNetwork(p):!n&&r&&this.setCaipNetworkOfNamespace(r,l),this.syncConnectedWalletInfo(l);let u=this.getAddress(l);G.HelpersUtil.isLowerCaseMatch(a,u)||this.syncAccountInfo(a,p?.id,l),n?await this.syncBalance({address:a,chainId:p?.id,chainNamespace:l}):await this.syncBalance({address:a,chainId:r?.id,chainNamespace:l}),this.syncIdentity({address:a,chainId:s,chainNamespace:l})}}async syncAccountInfo(e,t,n){let r=this.getCaipAddress(n),a=t||r?.split(":")[1];if(!a)return;let o=`${n}:${a}:${e}`;this.setCaipAddress(o,n,!0),await this.syncIdentity({address:e,chainId:a,chainNamespace:n})}async syncReownName(e,t){try{let n=await this.getReownName(e);if(n[0]){let e=n[0];this.setProfileName(e.name,t)}else this.setProfileName(null,t)}catch{this.setProfileName(null,t)}}syncConnectedWalletInfo(e){let t=r.ConnectorController.getConnectorId(e),n=R.getProviderId(e);if(n===Z.ConstantsUtil.CONNECTOR_TYPE_ANNOUNCED||n===Z.ConstantsUtil.CONNECTOR_TYPE_INJECTED){if(t){let n=this.getConnectors().find(e=>{let n=e.id===t,r=e.info?.rdns===t,a=e.connectors?.some(e=>e.id===t||e.info?.rdns===t);return n||r||!!a});if(n){let{info:t,name:r,imageUrl:a}=n,o=a||this.getConnectorImage(n);this.setConnectedWalletInfo({name:r,icon:o,...t},e)}}}else if(n===Z.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT){let t=R.getProvider(e);t?.session&&this.setConnectedWalletInfo({...t.session.peer.metadata,name:t.session.peer.metadata.name,icon:t.session.peer.metadata.icons?.[0]},e)}else if(t&&(t===i.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK||t===i.ConstantsUtil.CONNECTOR_ID.COINBASE)){let n=this.getConnectors().find(e=>e.id===t),r=n?.name||"Coinbase Wallet",a=n?.imageUrl||this.getConnectorImage(n),o=n?.info;this.setConnectedWalletInfo({...o,name:r,icon:a},e)}}async syncBalance(e){l.NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(),e.chainNamespace).find(t=>t.id.toString()===e.chainId?.toString())&&e.chainId&&await this.updateNativeBalance(e.address,e.chainId,e.chainNamespace)}async ready(){await this.readyPromise}async updateNativeBalance(e,n,r){let a=this.getAdapter(r),o=t.ChainController.getCaipNetworkByNamespace(r,n);if(a){let t=await a.getBalance({address:e,chainId:n,caipNetwork:o,tokens:this.options.tokens});return this.setBalance(t.balance,t.symbol,r),t}}async initializeUniversalAdapter(){let e=X.createLogger((e,...t)=>{e&&this.handleAlertError(e),console.error(...t)}),t={projectId:this.options?.projectId,metadata:{name:this.options?.metadata?this.options?.metadata.name:"",description:this.options?.metadata?this.options?.metadata.description:"",url:this.options?.metadata?this.options?.metadata.url:"",icons:this.options?.metadata?this.options?.metadata.icons:[""]},logger:e};o.OptionsController.setManualWCControl(!!this.options?.manualWCControl),this.universalProvider=this.options.universalProvider??await s.default.init(t),!1===o.OptionsController.state.enableReconnect&&this.universalProvider.session&&await this.universalProvider.disconnect(),this.listenWalletConnect()}listenWalletConnect(){this.universalProvider&&this.chainNamespaces.forEach(e=>{ep.listenWcProvider({universalProvider:this.universalProvider,namespace:e,onDisplayUri:e=>{n.ConnectionController.setUri(e)},onConnect:e=>{let{address:t}=a.CoreHelperUtil.getAccount(e[0]);n.ConnectionController.finalizeWcConnection(t)},onDisconnect:()=>{t.ChainController.state.noAdapters&&this.resetAccount(e),n.ConnectionController.resetWcConnection()},onChainChanged:n=>{let a=t.ChainController.state.activeChain,o=a&&r.ConnectorController.state.activeConnectorIds[a]===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(a===e&&(t.ChainController.state.noAdapters||o)){let e=this.getCaipNetworks().find(e=>e.id.toString()===n.toString()||e.caipNetworkId.toString()===n.toString()),t=this.getCaipNetwork();if(!e)return void this.setUnsupportedNetwork(n);t?.id.toString()!==e?.id.toString()&&t?.chainNamespace===e?.chainNamespace&&this.setCaipNetwork(e)}},onAccountsChanged:n=>{let a=t.ChainController.state.activeChain,o=a&&r.ConnectorController.state.activeConnectorIds[a]===i.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(a===e&&(t.ChainController.state.noAdapters||o)){let e=n?.[0];e&&this.syncAccount({address:e.address,chainId:e.chainId,chainNamespace:e.chainNamespace})}}})})}createUniversalProvider(){return!this.universalProviderInitPromise&&a.CoreHelperUtil.isClient()&&this.options?.projectId&&(this.universalProviderInitPromise=this.initializeUniversalAdapter()),this.universalProviderInitPromise}async getUniversalProvider(){if(!this.universalProvider)try{await this.createUniversalProvider()}catch(e){I.EventsController.sendEvent({type:"error",event:"INTERNAL_SDK_ERROR",properties:{errorType:"UniversalProviderInitError",errorMessage:e instanceof Error?e.message:"Unknown",uncaught:!1}}),console.error("AppKit:getUniversalProvider - Cannot create provider",e)}return this.universalProvider}getDisabledCaipNetworks(){let e=t.ChainController.getAllApprovedCaipNetworkIds(),n=t.ChainController.getAllRequestedCaipNetworks();return a.CoreHelperUtil.sortRequestedNetworks(e,n).filter(e=>t.ChainController.isCaipNetworkDisabled(e))}handleAlertError(e){let[t,n]=Object.entries(q).find(([,{message:t}])=>e.message.includes(t))??[],{message:r,alertErrorKey:a}=n??{};if(t&&r&&!this.reportedAlertErrors[t]){let e=$[a];e&&(d.AlertController.open(e,"error"),this.reportedAlertErrors[t]=!0)}}getAdapter(e){if(e)return this.chainAdapters?.[e]}createAdapter(e){if(!e)return;let t=e.namespace;t&&(this.createClients(),e.namespace=t,e.construct({namespace:t,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:e})=>e===t)}),this.chainNamespaces.includes(t)||this.chainNamespaces.push(t),this.chainAdapters&&(this.chainAdapters[t]=e))}async open(e){await this.injectModalUi(),e?.uri&&n.ConnectionController.setUri(e.uri);let{isSwap:t,isSend:r}=this.toModalOptions();return t(e)?T.ModalController.open({...e,data:{swap:e.arguments}}):r(e)&&e.arguments?this.openSend(e.arguments):T.ModalController.open(e)}async close(){await this.injectModalUi(),T.ModalController.close()}setLoading(e,t){T.ModalController.setLoading(e,t)}async disconnect(e){await n.ConnectionController.disconnect({namespace:e})}getSIWX(){return o.OptionsController.state.siwx}getError(){return""}getChainId(){return t.ChainController.state.activeCaipNetwork?.id}async switchNetwork(e,{throwOnFailure:n=!1}={}){let r=this.getCaipNetworks().find(t=>t.id===e.id);r?await t.ChainController.switchActiveNetwork(r,{throwOnFailure:n}):d.AlertController.open($.SWITCH_NETWORK_NOT_FOUND,"error")}getWalletProvider(){return t.ChainController.state.activeChain?R.state.providers[t.ChainController.state.activeChain]:null}getWalletProviderType(){return R.getProviderId(t.ChainController.state.activeChain)}subscribeProviders(e){return R.subscribeProviders(e)}getThemeMode(){return F.ThemeController.state.themeMode}getThemeVariables(){return F.ThemeController.state.themeVariables}setThemeMode(e){F.ThemeController.setThemeMode(e),(0,j.setColorTheme)(F.ThemeController.state.themeMode)}setTermsConditionsUrl(e){o.OptionsController.setTermsConditionsUrl(e)}setPrivacyPolicyUrl(e){o.OptionsController.setPrivacyPolicyUrl(e)}setThemeVariables(e){F.ThemeController.setThemeVariables(e),(0,j.setThemeVariables)(F.ThemeController.state.themeVariables)}subscribeTheme(e){return F.ThemeController.subscribe(e)}subscribeConnections(e){return this.remoteFeatures.multiWallet?n.ConnectionController.subscribe(e):(d.AlertController.open(i.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),()=>void 0)}getWalletInfo(e){if(e)return t.ChainController.state.chains.get(e)?.accountState?.connectedWalletInfo;let n=t.ChainController.getAccountData();return n?.connectedWalletInfo}getAccount(e){let o=e||t.ChainController.state.activeChain,s=r.ConnectorController.getAuthConnector(o),l=t.ChainController.getAccountData(o),c=A.StorageUtil.getConnectedConnectorId(t.ChainController.state.activeChain),d=n.ConnectionController.getConnections(o);if(!o)throw Error("AppKit:getAccount - namespace is required");let C=d.flatMap(e=>e.accounts.map(({address:e,type:t,publicKey:n})=>a.CoreHelperUtil.createAccount(o,e,t||"eoa",n)));if(l)return{allAccounts:C,caipAddress:l.caipAddress,address:a.CoreHelperUtil.getPlainAddress(l.caipAddress),isConnected:!!l.caipAddress,status:l.status,embeddedWalletInfo:s&&c===i.ConstantsUtil.CONNECTOR_ID.AUTH?{user:l.user?{...l.user,username:A.StorageUtil.getConnectedSocialUsername()}:void 0,authProvider:l.socialProvider||"email",accountType:(0,B.getPreferredAccountType)(o),isSmartAccountDeployed:!!l.smartAccountDeployed}:void 0}}subscribeAccount(e,n){let a=()=>{let t=this.getAccount(n);t&&e(t)};n?t.ChainController.subscribeChainProp("accountState",a,n):t.ChainController.subscribe(a),r.ConnectorController.subscribe(a)}subscribeNetwork(e){return t.ChainController.subscribe(({activeCaipNetwork:t})=>{e({caipNetwork:t,chainId:t?.id,caipNetworkId:t?.caipNetworkId})})}subscribeWalletInfo(e,n){return n?t.ChainController.subscribeChainProp("accountState",t=>e(t?.connectedWalletInfo),n):t.ChainController.subscribeChainProp("accountState",t=>e(t?.connectedWalletInfo))}subscribeShouldUpdateToAddress(e){t.ChainController.subscribeChainProp("accountState",t=>e(t?.shouldUpdateToAddress))}subscribeCaipNetworkChange(e){t.ChainController.subscribeKey("activeCaipNetwork",e)}getState(){return D.PublicStateController.state}getRemoteFeatures(){return o.OptionsController.state.remoteFeatures}subscribeState(e){return D.PublicStateController.subscribe(e)}subscribeRemoteFeatures(e){return o.OptionsController.subscribeKey("remoteFeatures",e)}showErrorMessage(e){W.SnackController.showError(e)}showSuccessMessage(e){W.SnackController.showSuccess(e)}getEvent(){return{...I.EventsController.state}}subscribeEvents(e){return I.EventsController.subscribe(e)}replace(e){v.RouterController.replace(e)}redirect(e){v.RouterController.push(e)}popTransactionStack(e){v.RouterController.popTransactionStack(e)}isOpen(){return T.ModalController.state.open}isTransactionStackEmpty(){return 0===v.RouterController.state.transactionStack.length}static getInstance(){return this.instance}updateFeatures(e){o.OptionsController.setFeatures(e)}updateRemoteFeatures(e){o.OptionsController.setRemoteFeatures(e)}updateOptions(e){let t={...o.OptionsController.state||{},...e};o.OptionsController.setOptions(t)}setConnectMethodsOrder(e){o.OptionsController.setConnectMethodsOrder(e)}setWalletFeaturesOrder(e){o.OptionsController.setWalletFeaturesOrder(e)}setCollapseWallets(e){o.OptionsController.setCollapseWallets(e)}setSocialsOrder(e){o.OptionsController.setSocialsOrder(e)}getConnectMethodsOrder(){return H.WalletUtil.getConnectOrderMethod(o.OptionsController.state.features,r.ConnectorController.getConnectors())}addNetwork(e,n){if(this.chainAdapters&&!this.chainAdapters[e])throw Error(`Adapter for namespace ${e} doesn't exist`);let r=this.extendCaipNetwork(n,this.options);this.getCaipNetworks().find(e=>e.id===r.id)||t.ChainController.addNetwork(r)}removeNetwork(e,n){if(this.chainAdapters&&!this.chainAdapters[e])throw Error(`Adapter for namespace ${e} doesn't exist`);this.getCaipNetworks().find(e=>e.id===n)&&t.ChainController.removeNetwork(e,n)}}let eI=!1;class eT extends ey{async open(e){r.ConnectorController.isConnected()||await super.open(e)}async close(){if(await super.close(),this.options.manualWCControl){let e=t.ChainController.getAccountData(this.activeChainNamespace)?.address;n.ConnectionController.finalizeWcConnection(e)}}async syncIdentity(e){return Promise.resolve()}async syncBalance(e){return Promise.resolve()}async injectModalUi(){if(!eI&&a.CoreHelperUtil.isClient()){if(await e.A(217703),await e.A(890065),!document.querySelector("w3m-modal")){let e=document.createElement("w3m-modal");o.OptionsController.state.disableAppend||o.OptionsController.state.enableEmbedded||document.body.insertAdjacentElement("beforeend",e)}eI=!0}}}function eb(e){return new eT({...e,basic:!0,sdkVersion:"html-core-1.8.7"})}e.s(["createAppKit",()=>eb],506115),e.i(506115),e.s(["AppKit",()=>eT,"createAppKit",()=>eb],603061)}]);