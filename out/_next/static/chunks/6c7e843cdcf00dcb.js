(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,836328,e=>{"use strict";var n,t,a,i,s=e.i(413310),r=e.i(791738),o=e.i(101037),c=e.i(769059),l=e.i(371250),d=e.i(150271),u=e.i(968413),g=e.i(928938),h=e.i(567143),p=e.i(740633),f=e.i(577506),A=e.i(548938),w=e.i(566050),m=e.i(808431),y=e.i(869156),v=e.i(671708),T=e.i(9286),S=e.i(115935),b=e.i(65965),I=e.i(503107),E=e.i(550488),O=e.i(992296),W=e.i(194331),C=e.i(159054),j=e.i(585464),U=e.i(322754),F=e.i(158810);let M=["solana:mainnet","solana:devnet","solana:testnet"];function _(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var x=0,P="__private_"+x+++"__implementation";function N(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var D=0;function L(e){return"__private_"+D+++"_"+e}var B=L("_address"),R=L("_publicKey"),k=L("_chains"),V=L("_features"),z=L("_label"),K=L("_icon");class Q{get address(){return N(this,B)[B]}get publicKey(){return N(this,R)[R].slice()}get chains(){return N(this,k)[k].slice()}get features(){return N(this,V)[V].slice()}get label(){return N(this,z)[z]}get icon(){return N(this,K)[K]}constructor({address:e,publicKey:n,label:t,icon:a}){Object.defineProperty(this,B,{writable:!0,value:void 0}),Object.defineProperty(this,R,{writable:!0,value:void 0}),Object.defineProperty(this,k,{writable:!0,value:void 0}),Object.defineProperty(this,V,{writable:!0,value:void 0}),Object.defineProperty(this,z,{writable:!0,value:void 0}),Object.defineProperty(this,K,{writable:!0,value:void 0}),N(this,B)[B]=e,N(this,R)[R]=n,N(this,k)[k]=M,N(this,z)[z]=t,N(this,K)[K]=a,N(this,V)[V]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===Q&&Object.freeze(this)}}function Y(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var G=0;function H(e){return"__private_"+G+++"_"+e}var J=H("_listeners"),$=H("_version"),Z=H("_name"),q=H("_icon"),X=H("_injection"),ee=H("_isPrivyWallet"),en=H("_accounts"),et=H("_on"),ea=H("_emit"),ei=H("_off"),es=H("_connected"),er=H("_connect"),eo=H("_disconnect"),ec=H("_signMessage"),el=H("_signAndSendTransaction"),ed=H("_signTransaction");function eu(e,...n){Y(this,J)[J][e]?.forEach(e=>e.apply(null,n))}function eg(e,n){Y(this,J)[J][e]=Y(this,J)[J][e]?.filter(e=>n!==e)}function eh(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:t,recoverEmbeddedWallet:a,openModal:i,privy:s,client:r}=(0,m.u)(),{user:o}=(0,E.u)(),{setModalData:c}=(0,y.a)(),{signWithUserSigner:l}=(0,j.u)();return{signMessage:({message:d,address:u,options:g})=>new Promise(async(h,p)=>{let f=(0,y.h)(o,u);if("privy"!==f?.walletClientType)return void p(new m.a("Wallet is not a Privy wallet",void 0,m.b.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:A,entropyIdVerifier:w}=(0,O.g)(o,f),v=(0,y.b)(f),T=(0,U.b)(d).toString("base64");if(T.length<1)return void p(new m.a("Message must be a non-empty string",void 0,m.b.INVALID_MESSAGE));let S=async()=>{let e;if(!o)throw Error("User must be authenticated before signing with a Privy wallet");let i=await r.getAccessToken();if(!i)throw Error("User must be authenticated to use their embedded wallet.");let c=n??await t(15e3);if(!c)throw Error("Failed to initialize embedded wallet proxy.");if(!await a({address:f.address}))throw Error("Unable to connect to wallet");if(v){let n=await (0,b.rpc)(s,l,{chain_type:"solana",method:"signMessage",params:{message:T,encoding:"base64"},wallet_id:f.id});if(!n.data||!("signature"in n.data))throw Error("Failed to sign message");e=n.data.signature}else{let{response:n}=await c.rpc({accessToken:i,entropyId:A,entropyIdVerifier:w,chainType:"solana",hdWalletIndex:f.walletIndex??0,requesterAppId:g?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:T}}});e=n.data.signature}return e};if(e({showWalletUIs:g?.uiOptions?.showWalletUIs}))try{let e=await S(),n=new Uint8Array((0,U.b)(e,"base64"));h({signature:n})}catch(e){p(e)}else c({signMessage:{method:"solana_signMessage",data:T,confirmAndSign:S,onSuccess:e=>{h({signature:new Uint8Array((0,U.b)(e,"base64"))})},onFailure:e=>{p(e)},uiOptions:g?.uiOptions??{}},connectWallet:{recoveryMethod:f.recoveryMethod,connectingWalletAddress:f.address,entropyId:A,entropyIdVerifier:w,isUnifiedWallet:v,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{p(new m.a("Failed to connect to wallet",e,m.b.UNKNOWN_CONNECT_WALLET_ERROR))}}}),i("EmbeddedWalletConnectingScreen")})}}function ep(){let{isHeadlessSigning:e,openModal:n}=(0,m.u)(),{setModalData:t}=(0,y.a)(),{signMessage:a}=eh(),{user:i}=(0,E.u)();return{signTransaction:async({transaction:s,options:r,chain:o="solana:mainnet",address:c})=>{async function l(e){let n,t,{signature:i}=await a({message:(0,U.a)(e),address:c,options:{...r,uiOptions:{...r?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:(n=structuredClone((0,T.getTransactionDecoder)().decode(e)),(t=(0,S.address)(c))in n.signatures&&(n.signatures[t]=i),new Uint8Array((0,T.getTransactionEncoder)().encode(n)))}}return e({showWalletUIs:r?.uiOptions?.showWalletUIs})?l(s):new Promise(async(e,a)=>{let d=(0,y.h)(i,c);if("privy"!==d?.walletClientType)return void a(new m.a("Wallet is not a Privy wallet",void 0,m.b.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:u,entropyIdVerifier:g}=(0,O.g)(i,d),h=(0,y.b)(d);function p(e){return n=>{a(n instanceof m.a?n:new m.a("Failed to connect to wallet",n,e))}}let f={account:d,transaction:s,chain:o,signOnly:!0,uiOptions:r?.uiOptions||{},onConfirm:l,onSuccess:e,onFailure:p(m.b.TRANSACTION_FAILURE)};t({connectWallet:{recoveryMethod:d.recoveryMethod,connectingWalletAddress:d.address,entropyId:u,entropyIdVerifier:g,isUnifiedWallet:h,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:p(m.b.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:f}),n("EmbeddedWalletConnectingScreen")})}}}let ef=new class extends W.default{setImplementation(e){_(this,P)[P]=e}async signMessage(e){return _(this,P)[P].signMessage(e)}async signAndSendTransaction(e){return _(this,P)[P].signAndSendTransaction(e)}async signTransaction(e){return _(this,P)[P].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,P,{writable:!0,value:void 0}),_(this,P)[P]=e}}({signTransaction:(0,m.l)("signTransaction was not injected"),signAndSendTransaction:(0,m.l)("signAndSendTransaction was not injected"),signMessage:(0,m.l)("signMessage was not injected")}),eA=new class{get version(){return Y(this,$)[$]}get name(){return Y(this,Z)[Z]}get icon(){return Y(this,q)[q]}get chains(){return M.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:Y(this,er)[er]},"standard:disconnect":{version:"1.0.0",disconnect:Y(this,eo)[eo]},"standard:events":{version:"1.0.0",on:Y(this,et)[et]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:Y(this,el)[el]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:Y(this,ed)[ed]},"solana:signMessage":{version:"1.0.0",signMessage:Y(this,ec)[ec]},"privy:":{privy:{signMessage:Y(this,X)[X].signMessage,signTransaction:Y(this,X)[X].signTransaction,signAndSendTransaction:Y(this,X)[X].signAndSendTransaction}}}}get accounts(){return Y(this,en)[en].slice()}get isPrivyWallet(){return Y(this,ee)[ee]}constructor({name:e,icon:n,version:t,injection:a,wallets:i}){Object.defineProperty(this,ea,{value:eu}),Object.defineProperty(this,ei,{value:eg}),Object.defineProperty(this,J,{writable:!0,value:void 0}),Object.defineProperty(this,$,{writable:!0,value:void 0}),Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,en,{writable:!0,value:void 0}),Object.defineProperty(this,et,{writable:!0,value:void 0}),Object.defineProperty(this,es,{writable:!0,value:void 0}),Object.defineProperty(this,er,{writable:!0,value:void 0}),Object.defineProperty(this,eo,{writable:!0,value:void 0}),Object.defineProperty(this,ec,{writable:!0,value:void 0}),Object.defineProperty(this,el,{writable:!0,value:void 0}),Object.defineProperty(this,ed,{writable:!0,value:void 0}),Y(this,J)[J]={},Y(this,et)[et]=(e,n)=>(Y(this,J)[J][e]?.push(n)||(Y(this,J)[J][e]=[n]),()=>Y(this,ei)[ei](e,n)),Y(this,es)[es]=e=>{null!=e&&(Y(this,en)[en]=e.map(({address:e})=>new Q({address:e,publicKey:C.base58.decode(e)}))),Y(this,ea)[ea]("change",{accounts:this.accounts})},Y(this,er)[er]=async()=>(Y(this,ea)[ea]("change",{accounts:this.accounts}),{accounts:this.accounts}),Y(this,eo)[eo]=async()=>{Y(this,ea)[ea]("change",{accounts:this.accounts})},Y(this,ec)[ec]=async(...e)=>{let n=[];for(let{account:t,...a}of e){let{signature:e}=await Y(this,X)[X].signMessage({...a,address:t.address});n.push({signedMessage:a.message,signature:e})}return n},Y(this,el)[el]=async(...e)=>{let n=[];for(let t of e){let{signature:e}=await Y(this,X)[X].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||"solana:mainnet",options:t.options});n.push({signature:e})}return n},Y(this,ed)[ed]=async(...e)=>{let n=[];for(let{transaction:t,account:a,options:i,chain:s}of e){let{signedTransaction:e}=await Y(this,X)[X].signTransaction({transaction:t,address:a.address,chain:s||"solana:mainnet",options:i});n.push({signedTransaction:e})}return n},Y(this,Z)[Z]=e,Y(this,q)[q]=n,Y(this,$)[$]=t,Y(this,X)[X]=a,Y(this,en)[en]=[],Y(this,ee)[ee]=!0,a.on("accountChanged",Y(this,es)[es],this),Y(this,es)[es](i)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:ef});var ew=e.i(480679),em=e.i(795972);e.i(76093);var ey=e.i(246258),ev=e.i(28679),eT=e.i(520586);e.i(248409),e.i(256815);var eS=e.i(578326),eb=e.i(118974),eI=((n=eI||{})[n.Uninitialized=0]="Uninitialized",n[n.Initialized=1]="Initialized",n),eE=((t=eE||{})[t.Legacy=0]="Legacy",t[t.Current=1]="Current",t),eO=((a=eO||{})[a.Nonce=0]="Nonce",a),eW=((i=eW||{})[i.CreateAccount=0]="CreateAccount",i[i.Assign=1]="Assign",i[i.TransferSol=2]="TransferSol",i[i.CreateAccountWithSeed=3]="CreateAccountWithSeed",i[i.AdvanceNonceAccount=4]="AdvanceNonceAccount",i[i.WithdrawNonceAccount=5]="WithdrawNonceAccount",i[i.InitializeNonceAccount=6]="InitializeNonceAccount",i[i.AuthorizeNonceAccount=7]="AuthorizeNonceAccount",i[i.Allocate=8]="Allocate",i[i.AllocateWithSeed=9]="AllocateWithSeed",i[i.AssignWithSeed=10]="AssignWithSeed",i[i.TransferSolWithSeed=11]="TransferSolWithSeed",i[i.UpgradeNonceAccount=12]="UpgradeNonceAccount",i);function eC(e){return!!e&&"object"==typeof e&&"address"in e&&(0,eb.isTransactionSigner)(e)}var ej=e.i(791500),eU=e.i(967053),eF=e.i(557770),eM=e.i(220512),e_=e.i(173387),ex=e.i(669504);function eP({rows:e}){return(0,s.jsx)(A.a,{children:e.filter(e=>!!e).map((e,n)=>null!=e.value||e.isLoading?(0,s.jsxs)(A.R,{children:[(0,s.jsx)(f.L,{children:e.label}),(0,s.jsx)(f.V,{$isLoading:e.isLoading,children:e.value})]},n):null)})}function eN(e){return BigInt(Math.floor(1e9*parseFloat(e)))}function eD(e){return+eL.format(parseFloat(e.toString())/1e9)}e.i(631508),e.i(676966);let eL=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function eB({tx:e,solanaClient:n,amount:t,asset:a,tokenPrice:i}){if(!e)return null;if("SOL"===a&&i){let a=eN(t),s=(0,eM.g)(a,i),r=await (0,U.f)({solanaClient:n,tx:e});return{amountInUsd:s,feeInUsd:i?(0,eM.g)(r,i):void 0,totalInUsd:(0,eM.g)(a+r,i)}}if("USDC"===a&&i){let a,s="$"+t,r=await (0,U.f)({solanaClient:n,tx:e}),o=(a=parseFloat(r.toString())/eM.L*i)<.01?0:a;return{amountInUsd:s,feeInUsd:(0,eM.g)(r,i),totalInUsd:"$"+(parseFloat(t)+o).toFixed(2)}}if("SOL"===a){let a=eN(t),i=await (0,U.f)({solanaClient:n,tx:e});return{amountInSol:t+" SOL",feeInSol:eD(i)+" SOL",totalInSol:eD(a+i)+" SOL"}}return{amountInUsdc:t+" USDC",feeInSol:eD(await (0,U.f)({solanaClient:n,tx:e}))+" SOL"}}let eR={component:function(){let e=(0,w.u)(),{closePrivyModal:n,createAnalyticsEvent:t}=(0,m.u)(),{data:a,setModalData:i,navigate:f}=(0,y.a)(),{wallets:A}=function(){let{ready:e,wallets:n}=function(){let{client:e}=(0,m.u)(),{ready:n,wallet:t}=function(){let{ready:e}=(0,O.u)(),{user:n}=(0,E.u)(),{signMessage:t}=eh(),{signTransaction:a}=ep(),{signAndSendTransaction:i}=function(){let e=(0,w.u)(),{isHeadlessSigning:n,openModal:t,privy:a}=(0,m.u)(),{setModalData:i}=(0,y.a)(),{signTransaction:s}=ep(),r=(0,U.u)(),{user:o}=(0,E.u)(),{signWithUserSigner:c}=(0,j.u)();return{signAndSendTransaction:async({transaction:l,address:d,chain:u="solana:mainnet",options:g})=>{let h=(0,y.h)(o,d);if("privy"!==h?.walletClientType)throw new m.a("Wallet is not a Privy wallet",void 0,m.b.EMBEDDED_WALLET_NOT_FOUND);let p=(0,y.b)(h);async function f(e){if(g?.sponsor)return await (async e=>{if(!p)throw new m.a("Sponsoring transactions is only supported for wallets on the TEE stack",m.b.INVALID_DATA);let n=await (0,b.rpc)(a,c,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:(0,U.b)(e).toString("base64"),encoding:"base64"},caip2:`solana:${(await r(u).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:h.id});if(n.data&&"hash"in n.data)return{signature:C.base58.decode(n.data.hash)};throw Error("Failed to sign and send transaction")})(e);let{signedTransaction:n}=await s({transaction:e,address:d,chain:u,options:{...g,uiOptions:{...g?.uiOptions,showWalletUIs:!1}}}),{signature:t}=await r(u).sendAndConfirmTransaction(n);return{signature:t}}return n({showWalletUIs:g?.uiOptions?.showWalletUIs})?f(l):new Promise(async(n,a)=>{let s,r,{entropyId:c,entropyIdVerifier:A}=(0,O.g)(o,h);function w(e){return n=>{a(n instanceof m.a?n:new m.a("Failed to connect to wallet",n,e))}}let y={account:h,transaction:l,chain:u,signOnly:!1,uiOptions:g?.uiOptions||{},onConfirm:f,onSuccess:n,onFailure:w(m.b.TRANSACTION_FAILURE),isSponsored:!!g?.sponsor},v={recoveryMethod:h.recoveryMethod,connectingWalletAddress:h.address,entropyId:c,entropyIdVerifier:A,isUnifiedWallet:p,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:w(m.b.UNKNOWN_CONNECT_WALLET_ERROR)};e.fundingConfig&&(s=(0,F.g)({address:d,appConfig:e,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...g,asset:"native-currency",chain:u},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),r={amount:e.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:u,destinationAddress:d,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),i({connectWallet:v,standardSignAndSendTransaction:y,funding:s,solanaFundingData:r}),t("EmbeddedWalletConnectingScreen")})}}}(),s=(0,o.useMemo)(()=>{let e=[...(0,y.n)(n).sort((e,n)=>(e.walletIndex??0)-(n.walletIndex??0))],t=(0,y.k)(n);return t.length?[...e,...t]:e},[n]),r=(0,o.useMemo)(()=>({signMessage:async({message:e,address:n,options:a})=>await t({message:e,address:n,options:a}),signTransaction:async({transaction:e,address:n,chain:t,options:i})=>await a({transaction:e,address:n,chain:t,options:i}),async signAndSendTransaction({transaction:e,address:n,chain:t,options:a}){let{signature:s}=await i({transaction:e,address:n,chain:t,options:a});return{signature:s}}}),[t,a,i]);return(0,o.useEffect)(()=>{ef?.setImplementation(r)},[r]),(0,o.useEffect)(()=>{var n;!e||(n=eA.accounts).length===s.length&&n.every((e,n)=>e.address===s[n]?.address)||ef?.emit("accountChanged",s)},[e,s]),{ready:e,wallet:eA}}(),[a,i]=(0,o.useState)([]),[s,r]=(0,o.useState)([]);return(0,o.useEffect)(()=>{let e=[t,...a.filter(e=>"solana"===e.chainType&&!!e.wallet.features).map(e=>e.wallet)];r(e);let n=a.flatMap(n=>{let t=()=>r([...e]);return n.on("walletsUpdated",t),{connector:n,off:t}}),i=e.map(n=>n.features["standard:events"]?.on("change",()=>{r([...e])}));return()=>{i.forEach(e=>e?.()),n.forEach(({connector:e,off:n})=>e.off("walletsUpdated",n))}},[a]),(0,o.useEffect)(()=>{i(e.connectors?.walletConnectors.filter(e=>"solana"===e.chainType)??[]);let n=()=>{i(e.connectors?.walletConnectors.filter(e=>"solana"===e.chainType)??[])};return e.connectors?.on("connectorInitialized",n),()=>{e.connectors?.off("connectorInitialized",n)}},[n,e.connectors]),{ready:n,wallets:s}}();return{ready:e,wallets:(0,o.useMemo)(()=>n.flatMap(e=>e.accounts.map(n=>new I.ConnectedStandardSolanaWallet({wallet:e,account:n}))),[n])}}(),[S,W]=(0,o.useState)("preparing"),[M,_]=(0,o.useState)(),[x,P]=(0,o.useState)(),[N,D]=(0,o.useState)();if(!a?.solanaFundingData)throw Error("Funding config is missing");if(!a.solanaFundingData.sourceWalletData)throw Error("Funding config is missing source wallet data");let{amount:L,asset:B,chain:R,sourceWalletData:k,destinationAddress:V,afterSuccessScreen:z}=a.solanaFundingData,K=A.find(e=>e.address===k.address&&(0,F.t)(k.walletClientType)===(0,F.t)(e.standardWallet.name)),Q=(0,U.u)()(R),{tokenPrice:Y,isTokenPriceLoading:G}=(0,ew.u)("solana");return(0,o.useEffect)(()=>{if("preparing"!==S||G||!K)return;let e="SOL"===B?eN(L):BigInt(Math.floor(1e6*parseFloat(L)));P({amount:("SOL"===B&&Y?(0,eM.g)(e,Y):L)??L}),("SOL"===B?async function({solanaClient:e,source:n,destination:t,amountInLamports:a}){let{value:i}=await e.rpc.getLatestBlockhash().send(),s={address:n},r=(0,ej.pipe)((0,eU.createTransactionMessage)({version:0}),e=>(0,eb.setTransactionMessageFeePayerSigner)(s,e),e=>(0,eU.setTransactionMessageLifetimeUsingBlockhash)(i,e),e=>{var n;let i,r,o,c;return(0,eU.appendTransactionMessageInstruction)((i=(void 0)??"11111111111111111111111111111111",r={source:{value:(n={amount:a,source:s,destination:t}).source??null,isWritable:!0},destination:{value:n.destination??null,isWritable:!0}},o={...n},Object.freeze({accounts:[(c=e=>{if(!e.value)return;let n=e.isWritable?eS.AccountRole.WRITABLE:eS.AccountRole.READONLY;return Object.freeze({address:function(e){if(!e)throw Error("Expected a Address.");return"object"==typeof e&&"address"in e?e.address:Array.isArray(e)?e[0]:e}(e.value),role:eC(e.value)?(0,eS.upgradeRoleToSigner)(n):n,...eC(e.value)?{signer:e.value}:{}})})(r.source),c(r.destination)],data:(0,eT.transformEncoder)((0,ey.getStructEncoder)([["discriminator",(0,ev.getU32Encoder)()],["amount",(0,ev.getU64Encoder)()]]),e=>({...e,discriminator:2})).encode(o),programAddress:i})),e)},e=>(0,T.compileTransaction)(e));return new Uint8Array((0,T.getTransactionEncoder)().encode(r))}({solanaClient:Q,source:K.address,destination:V,amountInLamports:e}):async function({solanaClient:e,source:n,destination:t,amountInBaseUnits:a}){let i=(0,e_.g)(e.chain),{value:s}=await e.rpc.getLatestBlockhash().send(),r={address:n},[o]=await (0,eF.findAssociatedTokenPda)({mint:i,owner:n,tokenProgram:eM.T}),[c]=await (0,eF.findAssociatedTokenPda)({mint:i,owner:t,tokenProgram:eM.T}),[l,d]=await Promise.all([e.rpc.getAccountInfo(o,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null),e.rpc.getAccountInfo(c,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null)]);if(!l?.value)throw Error(`Source token account does not exist for address: ${n}`);let u=(0,eF.getCreateAssociatedTokenIdempotentInstruction)({payer:r,ata:c,owner:t,mint:i}),g=(0,ej.pipe)((0,eU.createTransactionMessage)({version:0}),e=>(0,eb.setTransactionMessageFeePayerSigner)(r,e),e=>(0,eU.setTransactionMessageLifetimeUsingBlockhash)(s,e),e=>d?.value?e:(0,eU.appendTransactionMessageInstruction)(u,e),e=>(0,eU.appendTransactionMessageInstruction)((0,eF.getTransferInstruction)({source:o,destination:c,authority:r,amount:a}),e),e=>(0,T.compileTransaction)(e));return new Uint8Array((0,T.getTransactionEncoder)().encode(g))}({solanaClient:Q,source:K.address,destination:V,amountInBaseUnits:e})).then(_).catch(e=>{W("error"),D(e)})},[S,L,B,R,K,V,G,Y]),(0,o.useEffect)(()=>{"preparing"===S&&M&&eB({tx:M,solanaClient:Q,amount:L,asset:B,tokenPrice:Y}).then(e=>{W("loaded"),P({amount:e?.amountInUsd??e?.amountInUsdc??e?.amountInSol??L,fee:e?.feeInUsd??e?.feeInSol,total:e?.totalInUsd??e?.totalInSol})}).catch(e=>{W("error"),D(e)})},[M,L,B,S,Y]),(0,o.useEffect)(()=>{"error"===S&&N&&(i({errorModalData:{error:N,previousScreen:"FundSolWalletWithExternalSolanaWallet"},solanaFundingData:a.solanaFundingData}),f("ErrorScreen",!1))},[S,f]),(0,o.useEffect)(()=>{if("success"!==S)return;let e=setTimeout(z?()=>f(z):n,w.t);return()=>clearTimeout(e)},[S]),(0,s.jsxs)(s.Fragment,"success"===S?{children:[(0,s.jsx)(g.t,{}),(0,s.jsx)(d.b,{}),(0,s.jsxs)(d.c,{children:[(0,s.jsx)(r.default,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),(0,s.jsx)(u.C,{title:"Success!",description:`Youâ€™ve successfully added ${L} ${B} to your ${e.name} wallet. It may take a minute before the funds are available to use.`})]}),(0,s.jsx)(d.R,{}),(0,s.jsx)(l.B,{})]}:"preparing"===S||"loaded"===S||"sending"===S?{children:[(0,s.jsx)(g.t,{}),(0,s.jsx)(d.e,{style:{marginTop:"16px"},children:(0,s.jsx)(h.I,{icon:K?.standardWallet.icon,name:K?.standardWallet.name})}),(0,s.jsx)(u.C,{style:{marginTop:"8px",marginBottom:"12px"},title:"sending"===S&&K?`Confirming with ${K.standardWallet.name}`:"Confirm transaction"}),(0,s.jsx)(eP,{rows:[{label:"Source",value:(0,c.formatWalletAddress)(k.address)},{label:"Destination",value:(0,c.formatWalletAddress)(V)},{label:"Network",value:(0,ex.g)(R)},{label:"Amount",value:x?.amount,isLoading:"preparing"===S},{label:"Estimated fee",value:x?.fee,isLoading:"preparing"===S},{label:"Total",value:x?.total,isLoading:"preparing"===S}]}),(0,s.jsx)(l.P,{style:{marginTop:"1rem"},loading:"preparing"===S||"sending"===S,onClick:function(){"loaded"===S&&M&&K&&(W("sending"),(async function({transaction:e,chain:n,sourceWallet:t,solanaClient:a}){var i;let{hasFunds:s}=await (0,U.s)({solanaClient:a,tx:e});if(!s)throw new m.a(`Wallet ${(0,c.formatWalletAddress)(t.address)} does not have enough funds.`,void 0,m.b.INSUFFICIENT_BALANCE);let r=(i=(await t.signAndSendTransaction({transaction:e,chain:n}).catch(e=>{throw new m.a("Transaction was rejected by the user",e,m.b.TRANSACTION_FAILURE)})).signature,(0,v.getBase58Decoder)().decode(i));return await (0,U.w)({rpcSubscriptions:a.rpcSubscriptions,signature:r,timeout:2e4}),r})({solanaClient:Q,transaction:M,chain:R,sourceWallet:K}).then(e=>{W("success"),t({eventName:em.O,payload:{provider:"external",status:"success",txHash:e,address:K.address,value:L,chainType:"solana",clusterName:R,token:B,destinationAddress:V,destinationValue:L,destinationChainType:"solana",destinationClusterName:R,destinationToken:B}})}).catch(e=>{W("error"),D(e)}))},children:"Confirm"}),(0,s.jsx)(l.B,{})]}:{children:[(0,s.jsx)(g.t,{}),(0,s.jsx)(p.N,{}),(0,s.jsx)("div",{style:{marginTop:"1rem"}}),(0,s.jsx)(l.B,{})]})}};e.s(["FundSolWalletWithExternalSolanaWallet",()=>eR,"default",()=>eR],836328)}]);